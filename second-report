引言
unix环境高级编程一书是描述UNIX系统的程序设计接口——系统调用接口和标准C库提供的函数。
本书的组织
	本书分为6个部分：
1.第1~2章介绍基本概念和各种实现的讨论；
2.第3~6章介绍I/O；
3.第7~10章介绍进程；
4.第11~12章介绍更多I/O；
5.第14~15章介绍IPC；
6.第16~19章介绍实例；
第1章  UNIX基础知识
unix体系结构
内核是控制计算机硬件资源，提供程序运行环境。
内核的接口被称为系统调用，公共函数库构建在系统调用接口智商，应用程序可使用公用函数库，也可使用系统调用。shell是一个特殊的应用程序，为运行其他应用提供一个接口。














文件与目录
1.文件系统
unix文件系统是目录和文件的一种层次结构，所有东西的起点是根（root（/））目录。
目录是一个包含目录项的文件。在逻辑上，可以认为每个目录项都包含一个文件名，同时还抱哈说明该文件属性的信息。
2.文件名
目录中的各个名字称为文件名。创建新目录时会自动创建两个文件名：.（当前目录）和..（父目录），在根目录，..与.相同。
3.路径名
由/分隔的一个或多个文件名组成的序列构成路径名，相对路径名与绝对路径名的区别。
4.工作目录：当前工作的命令
5.起始目录：登录时的工作目录
输入和输出
1.文件描述符：非负整数，内核用以标志一个特定进程正在访问的文件。当内核打开一个现有文件或创建一个新文件时，内核会返回一个文件描述符；在读、写文件时，使用这个文件描述符。
2.标准输入、标准输出和标准错误
每当运行一个新程序时，所有的shell都为其打开3个文件描述符，这个3个描述符都链接向终端。大多数shell都提供一种方法，将描述符重定向到某个文件，例如：
ls > file.list
3.不带缓冲的I/O
函数open、read、write、lseek以及close提供不带缓冲的I/O。这些函数都使用文件描述符。
./a.out  >  data
标准输入是终端，标准输出重新定向至文件data，标准错误也是终端。
4.标准I/O
标准I/O函数为不带缓冲的I/O函数提供了一个带缓冲的接口。使用标准I/O函数无需担心如何选取最佳的缓冲区大小，为固定大小。
进程和线程
1.程序：一个存储在磁盘上某个目录中的可执行文件。内核使用exec函数将程序读入内存，并执行程序。
2.进程和进程ID：程序的执行实例被称为进程。进程有进程ID（非负整数）。
3.进程控制：fork、exec、waitpid
4.线程和线程ID
通常，一个进程只有一个控制线程。多个控制线程可以充分利用多处理系统的并行能力。
一个进程内的所有线程共享同一地址空间、文件描述符、栈以及进程相关的属性。因为他们能访问同一存储区，所以各线程在访问共享数据时需要采取同步措施以避免不一致。
线程也有线程ID。
出错处理
当unix系统函数出错时，返回负值。
出错分为两类：致命性和非致命性。对于致命性错误，系统无法执行恢复动作。最多能做的是在用户屏幕上打印一条出错信息或者将一条出错信息写入日志文件中，然后退出。对于非致命性错误，有时候可以妥善处理，大多数非致命性错误是短暂的（资源短暂）；如输出缓存已满，write函数报错，延迟一段时间之后，write函数可以继续往输出缓存中写数据。
用户标志
1.用户ID：一个数值，用于标志各个不同的用户。用户ID为0的用户为根用户或者超级用户。
2.组ID：由系统管理员在指定用户登录名时分配的。组被用于将若干用户集合到项目或部门中。这种机制允许同组的各个成员之间共享资源。
3.附属组ID：允许一个用户属于另外一些组。
信号
信号用于停止进程发生了某种情况，进程有以下3种信号处理方式：
1.忽略信号。
2.按系统默认方式处理。
3.提供一个函数，信号发生时调用该函数，被称为捕捉该信号。
时间值
1.日历时间：系统基本数据类型time_t用于保存这种时间值。
2.进程时间：CPU时间，用于度量进程使用的中央处理器资源。进程以式中滴答计算。系统基本数据类型clock_t保存这种时间值。
当度量一个进程的执行时间时，unix系统为一个进程维护3个进程时间值：
时钟时间——进程运行的时间总量，其值与系统中同时运行的进程数有关；
用户CPU时间——执行用户指定所用的时间量，；
系统CPU时间——该进程执行内核程序所经历的时间。
系统调用和库函数
所有的操作系统都提供多种服务的入口点，由此程序向内核请求服务，称为系统调用。
库函数可能会调用一个或多个内核的系统调用。
应用程序既可以调用系统调用越可以调用库函数。很多库函数会调用系统调用。
系统调用和库函数之间的另一个差别是：系统调用通常提供一种最小接口，而库函数通常是提供比较复杂的功能。
进程控制的系统调用（fork、exec和wait）通常由用户应用程序。















第2章  UNIX标准及实现
unix标准化
ISO C
ISO C标准定义的头文件
assert.h：验证程序断言
complex.h：复数算术运算支持
ctype.h：字符分类和映射支持
errno.h：出错码
fenv.h：浮点环境
float.h：浮点常量及特性
inttypes.h：整型格式变换
iso646.h：赋值、关系及一元操作符宏
limits.h：实现常量
locale.h：本地化类别及相关定义
math.h：数学函数、类型说明及常量
setjmp.h：非局部goto
signal.h：信号
stdarg.h：可变长度参考表
stdbool.h：布尔类型和值
stddef.h：标准定义
stdint.h：整型
stdio.h：标准IO库
stdlib.h：使用函数
string.h：字符串操作
tgmath.h：通用类型数学宏
time.h：时间和日期
wchar.h：扩充的多字符和宽字符支持
wctype.h：宽字符分类和映射支持
IEEE POSIX
POSIX标准定义的必须的头文件
aio.h：异步I/O
cpio.h：cpio归档值
dirent.h：目录项
dlfcn.h：动态链接
fcntl.h：文件控制
fnamtch.h：文件名匹配类型
glob.h：路径名模式匹配与生成
grp.h：组文件
iconv.h：代码集变换实用程序
langinfo.h：语言信息常量
monetary.h：货币类型与函数
netdb.h：网络数据库操作
nl_types.h：消息类
poll.h：投票函数
pthread.h：线程
pwd.h：口令文件
regex.h：正则表达式
sched.h：执行调度
semaphore.h：信号量
strings.h：字符串操作
tar.h：tar归档值
termios.h：终端I/O
unistd.h：符号常量
wordexp.h：字扩充类型
arpa/inet.h：因特网定义
net/if.h：套接字本地接口
netinet/in.h：因特网地址簇
netinet/tcp.h：传输控制协议定义
sys/mman.h：存储管理说明
sys/select.h：select函数
sys/sockect.h：套接字接口
sys/stat.h：文件状态
sys/statvfs.h：文件系统信息
sys/times.h：进程时间
sys/types.h：基本系统数据类型
sys/un.h：unix域套接字定义
sys/utsname：系统名
sys/wait.h：进程控制
Single UNIX Specification
SUS是POSIX.1标准的一个超级
unix系统实现
标准只是接口的规范。具体实现有下几种版本：
SVR4：AT&T的unix系统实验室的产品；
BSD：加州大学伯克利分销的计算机系统研究组研究开发和分发的；
FreeBSD：基于BSD-Lite操作系统；
Linux：类似于UNIX的丰富编程环境的操作系统；
Mac OS X：UNIX系统；
Solaris：Oracle开发的UNIX系统版本；
第3章  文件I/O
文件描述符
对内核而言，所有打开的文件都是通过文件描述符引用。当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。当读、写一个文件时，使用open或creat返回的文件描述符标志该文件，并将其作为参数抄送给read或write。
unix系统shell把文件描述符0与进程的标准输入关联，文件描述符1与标准输出关联，文件描述2与标准错误关联;并将它们替换成富豪常量STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO.
文件描述符的变化范围是0~OPEN_MAX-1。目前很多系统将OPEN_MAX设置为64。
函数open和openat
调用open和openat函数可以打开或者创建一个文件。
…表示参数的数量以及类型是可变的。
path参数是要打开或穿件文件的名字。oflag参数可用来说明此函数的多个选项，如以下所示。
O_RDONLY 只读打开；
O_WRONLY 只写打开；
O_RDWR   读、写打开；
O_EXEC  只执行打开；
O_SEARCH 只搜索打开；
O_APPEND 每次写时都追加到文件的尾端；
O_CLOEXEC 把FD_CLOEXEC常量设置为文件描述符标志；
O_CREAT  若文件不存在则创建它；
O_NONbLOCK  如果path引用的是一个FIFO、一个块特殊文件或一个字符特殊文件，则此选项为文件的本次打开操作和后续的I/O操作设置非阻塞方式。
由open和openat函数返回的文件描述符一定是最小的未用描述符数值。这一点被某些应用程序用来在标准输入、标准输出、标准错误上打开新的文件。
函数creat
creat用于创建一个新文件，不足之处是它以致谢方式打开所创建的文件。在提供open的新版之前，如果要创建一个老师文件，要先写该文件，然后又读该文件，则必须先调用create、close，然后在调用open。现在则可用下列方式调用open实现。
函数close
close函数关闭一个打开文件。
关闭一个文件时还会释放该进程加在该文件上的所有记录锁。
当一个进程终止时，内核自动关闭它所有的打开文件。
函数lseek
每个打开文件都有一个与其相关联的“当前文件偏移量”。通常，读、写操作都从当前文件偏移量处开始，并使偏移量增加所读写的字符数。按系统默认的情况，当打开你一个文件时，除非指定O_APPEND选项，否则该偏移量被设置为0.
lseek函数显式地为一个打开文件设置偏移量。
#include <unistd.h>
off_t lseek(int fd, off_t offset, int whence);
对参数offset的解释与参数whence的值有关。
1.若whence是SEEK_SET，则将该文件的偏移量设置为距文件开始处offset个文件；
2.若whence是SEEK_CUR，则将该文件的偏移量设置为当前值加offset，offset可为正或负；
3.若whence是SEEK_END，则将该文件的偏移量设置为文件长度加offset，offset可正可负。
若lseek成功执行，则返回新的文件偏移量。
函数read
调用read函数从打开文件中读取数据。
如果read成功，则返回读到的字节数。如已发到达文件的尾端，则放回0.
实际读到的字节数少于要求读的字节数的情况如下所示：
1.当读取普通文件时，达到文件尾端；
2.当从终端设备读时，通常一次最多读取一行；
3.当从网络读时，网络中的缓冲机制可能造成返回值小于所要求的读的字节数；
4.当从管道或FIFO读时，如若管道包含的字节少于所需的数量，那么read将只返回实际可用的字节数；
5.当从某些面向记录的设备读时，一次最多返回一个记录；
6.当一信号造成中断，而已经读了部分数据量时。
函数write
write函数用于打开文件写数据。
返回值通常与参数nbytes的值相同，否则表示出错。write出错的一个常见原因是磁盘已写满，或者超过了一个给定进程的文件长度限制。
对于普通文件，写操作从文件的当前偏移量处开始。
文件共享
unix相同支持在不同进程间共享打开文件。
内核使用3种数据结构表示打开文件，他们之间的关系决定了在文件共享方面一个进程对一个进程可能产生的影响。
（1）每个进程在进程表中都有一个记录项，记录项中包含一张打开文件描述符，可将其视为一个矢量，每个描述符占用一项。与每个文件描述符相关联的是：
a.文件描述符标志；
b.指向一个文件表项的执政。
（2）内核为所有打开文件维持一张文件表。每个文件表包含：
a.文件状态标志；
b.当前文件偏移量；
c.指向该文件v节点表项的指针。
（3）每个打开文件都有一个v节点（v-node）结构。v节点包含了文件类型和对此文件进行各种操作函数的指针。对于大多数文件，v节点还包含该文件的i节点。这些信息是在打开文件时从磁盘上读入内存的，所以，文件的所有相关信息都是随时可用的。i节点包含了文件的所有者、文件长度、指向文件实际数据库在磁盘上所在位置的指针等。fd为0是标准输出，fd为1是标准输出，如下所示。






















1.在完成每个write后，在文件表项中的当前文件偏移量即增加所写入的字节数；
2.如果用O_APPEND标志打开一个文件，文件表项中的当前文件偏移量会被设置为i节点表项中的文件长度；
3.若一个文件用lseek定位到文件当前的尾端，则文件表项中的当前偏移量被设置为i节点表项中的当前文件长度；
4.lseek函数只修改文件表项中的当前文件偏移量，不进行任何I/O操作；
原子操作
1.追加到一个文件
打开文件时设置O_APPEND状态，内核在每次写操作之前，都将进程的当前偏移量设置到该文件的尾端处。
2.函数pread和pwrite
调用pread相当于调用lseek后调用read，但是pread又与这种顺序调用有下列主要区别：
调用pread时，无法中断其定位和读操作；
不更新当前文件偏移量。
调用pwrite相当于调用lseek后调用write
3.创建一个文件






在open和creat之间，另一个程序创建该文件，就会出现问题。如若将这两者合并在一个院子操作中，这种问题就不会出现。
一般而言，原子操作指的是由多步组成的一个操作。如果该操作原子地执行，则要么执行完所有步骤，要么一步也不执行，不可能只执行所有步骤的一个子集。
函数dup和dup2
dup和dup2函数用来复制现有的一个文件描述符。
#include <unistd.h>
int dup(int fd);
int dup2(int fd, int fd2);
由dup返回的新文件描述符一定是当前可用文件描述符的最小数值。对于dup2，可以用fd2执行新描述符的值。如果fd2已经打开，则先将其关闭。如若fd等于fd2，则dup2返回fd2，则不关闭它。新文件描述符与参数fd共享同一个文件表项，如dup(1)的内核数据结构如下图所示。









函数sync、fsync和fdatasync
当我们向文件写入数据时，内核通常先将数据复制到缓冲区，然后排入对垒，随后写入磁盘（延迟写）。
通常，当内核需要重用缓冲区来存放其他磁盘快数据时，它会把延迟写数据块写入磁盘。为了保证磁盘上实际文件系统与缓冲区中内容的一致性，unix系统提供了sync、fsync和fdatasync三个函数。
sync只有将所有修改过的块缓冲区排入写队列，然后就返回，并不等待实际写磁盘操作结束。
通常，称为update的系统守护进程周期性地调用sync函数。这就保证了定期冲洗内核的块缓冲区。
fsync函数只对由文件描述符fd指定的一个文件起作用，并且等待写磁盘操作结束后才返回。fsync可用数据库这样的应用程序，这种应用程序需要确保修改过的块立即写到磁盘上。
fdatasync函数类似于fsync，但它只影响文件的数据部分。而除数据外，fsync还会同步更新文件的属性。
函数fcntl
fctnl函数可以改变已经打开文件的属性，有以下5种功能：
1.复制一个已有的描述符；
2.获取/设置文件描述符标志；
3.获取/设置文件状态标志；
4.获取/设置异步I/O所有权；
5.获取/设置记录锁。
函数ioctl
ioctl函数是IO操作的杂物箱，函数形式为int ioctl(int fd,int request,…);
磁带操作使我们可以在磁带上写一个文件结束标志、倒带、越过指定个数的文件或记录等，用其他函数都难于表达这些操作。
/dev/fd
较新的系统都提供名为/dev/fd的目录，其目录是名为0、1、2等的文件。打开文件/dev/fd/n等效于复制描述符n。
如fd = open(“/dev/fd/0”,mode)等效于fd=dup(0)，注意：描述符0与fd共享同一个文件表项，所以描述符原本是何种模式，fd就是何种模式，mode常常被忽略。
/dev/fd文件主要由shell使用，它允许使用路径名作为调用参数的程序，能用处理其他路径名的相同方式处理标准输入和输出。例如使用/dev/fd/0作为标准输入。
第4章  文件与目录
函数stat、fstat、fstatat、lstat
int stat(const char *restrict pathname, struct stat *restrict buf);
int fstat(int fd, struct stat *buf);
int fstatat(const char *restrict pathname, struct stat *restrict buf);
int lstat(int fd, const char *restrict pathname, struct stat *restrict buf, int flag);
一旦给出pathname，stat函数将返回与此命名文件相关的信息结构。fstat函数获得已在描述符fd上打开文件的有关信息。lstat函数类似于stat，但是命名的文件是一个符号链接时，lstat返回该符号链接的相关信息，而不是由该符号链接引用的文件信息。
fstatat函数为一个相对于当前打开目录的路径名返回文件统计信息。flag参数控制着是否跟随着一个符号链接。
文件类型
文件类型：普通文件和目录。
（1）普通文件。这种文件包含了某种形式的数据，可能是文本，也可能是二进制数据。对普通文件内容的解释由处理该文件的应用程序进行。
（2）目录文件。这种文件包含其他文件的名字以及指向与这些文件有关信息的指针。对一个目录文件具有读权限的任一进程都可以读该目录的内容，但只有内核可以直接写目录文件。进程必须使用本章介绍的函数才能更改目录。
（3）块特殊文件。这种类型的文件通过对设备（如磁盘）带缓冲的访问，每次访问以固定长度为单位进行。
（4）字符特殊文件。这种类型的文件提供对设备不带缓冲的访问，每次访问长度可变。系统中的所有设备要么是字符特殊文件，要么是块特殊文件。
（5）FIFO。这种类型的文件用于进程间通信，有时称为命名管道。
（6）套接字。这种类型的文件用于进程间的网络通信。套接字也可用于在一台宿主机上进程之间的非网络通信。
（7）符号链接。这种类型的文件指向另一个文件。
设置用户ID和设置组ID
与一个进程相关联的ID有6个。
实际用户：实际用户ID和实际组ID；这两个ID在登录时取自口令文件中的登录项。
用于文件访问权限调查：有效用户ID、有效组ID、附属组ID；这三个ID决定了文门的文件访问权限。
由exec函数保存：保存的设置用户ID、保存的设置组ID；这两个ID在执行一个程序时包含了有效用户ID和有效组ID的副本。
通常，有效用户ID等于实际用户ID，有效组ID等于实际组ID。
每个文件有一个所有者和组所有者。
文件访问权限
所有文件类型都有访问权限，且每个文件都有9个访问权限位，可分为3类：
1.用户所有者u：用户读、写、执行；
2.组g：组读、写、执行；
3.其他o：其他读、写、执行。
文件的所有者ID(实际用户ID和实际组ID)是文件的性质，进程的有效ID(有效用户ID、有效组ID)以及进程的附属组ID是检测恒的性质。内核进行的测试具体如下：
（1）若进程的有效用户ID是0（超级用户），则允许访问。超级用户对整个文件系统进行处理；
（2）若进程的有效用户ID等于文件的所有者ID，那么如果所有者适当的访问权限位被设置，则允许访问；否则拒绝访问。适当的访问权限位指的是，若进程为读而打开该文件，则用户读位应为1；若进程为写而打开该文件，则用户写位应为1；若进程为执行而打开该文件，则用户执行位应为1；
（3）若进程的有效组ID或附属组ID之一等于文件的组ID，那么如果组适当的访问权限位被设置，则允许访问；否则拒绝访问。
（4）若其他用户适当的访问权限位被设置，则允许访问；否则拒绝访问。
新文件和目录的试用期
新文件的用户ID设置为进程的有效用户ID：
（1）新文件的组ID可以使进程的有效组ID；
（2）新文件的组ID可以使它所在目录的组ID。
函数access和faccessat
当用open函数打开一个文件时，内核以进程的有效用户ID和有效组ID为基础执行其访问权限测试。access和faccessat函数是按实际用户ID和实际组ID进行访问权限测试的。
函数umask
umask函数为进程设置文件模式创建屏蔽字，并返回之前的值。
在进程创建一个新文件或新目录时，就一定会使用文件模式创建屏蔽字节，指定新文件的访问权限位。
函数chmod、fchmod、fchmodat
chmod、fchmod、fchmodat这3个函数可以更改现有文件的访问权限：
int chmod(const char *pathname, mode_t mode);
int fchmod(int fd, mode_t mode);
int fchmodat(int fd, const char *pathname, mode_t mode, int flag);
chmod函数在指定的文件上进行操作，而fchmod函数则对已打开的文件进行操作。fchmodat函数与chmod函数在下面两张情况下相同：一种是pathname参数为绝对路径，另一种是fd参数取值为AT_FDCWD而pathname参数为相对路径。否则，fchmodat计算相对于打开目录的pathname。
粘着位
S_ISVTX位被称为粘着位，如果一个可执行程序文件的这一位被设置了，那么当该程序第一次被执行，在其终止时，程序正文部分的一个副本仍被保存在交换区。这使得下次执行该程序时能较快地将其装载入内存。
如果对一个目录设置了粘着位，只有对该目录具有写权限的用户并且满足下列条件之一，才能删除或重命名该目录下的文件：
1.拥有此文件；
2.拥有此目录；
3.是超级用户。
目录/tmp和/var/tmp是设置粘着位的典型会选择——任何用户都可在这两个目录中创建文件。任一用户对这两个目录的权限通常都是读写和执行。但是用户不应能删除或重命名属于其他人的文件，为此在这两个目录的文件模式中都设置粘着位。
函数chown、fchown、fchownat和lchown
以上函数可用于更改文件的用户ID和组ID。如果两个参数owner或group中的任意一个是-1，则对应的ID不变。
fchown函数改变fd参数执行的打开文件的所有者，既然它在一个已打开的文件操作，就并不能用于改变符号链接所有者。
文件长度
stat结果成员st_size表示以字节为单位的文件的长度。此字段只对普通文件、目录文件和符号链接有意义。
对于普通文件，其文件长度可以为0；对于目录，文件长度通常是一个数的整数倍；对于符号链接，文件长度是在文件名中的实际字节数，如，文件长度7就是路径名为usr/lib的长度。
文件中的空洞
平台文件中可能包含空洞，空洞是由所设置的偏移量超过文件尾端，并写入了某些数据后造成的。
对于没有写过的字节位置，read函数读到的字节是0，如果执行wc –c命令，可以看出正常的I/O操作整个文件长度。如果使用实用程序复制这个文件，那么所有这些空洞都会被填满，其只所有实际数据字节皆填写为0。
文件截断
truncate和ftruncate函数在文件尾端处截去一些数据以缩短文件。将一个文件的长度截断为0是一个特例。这两个函数将一个现有文件长度截断为固定长度length。如果该文件以前的长度大于length，则超过length以外的数据就不再能访问。如果以前的长度小于length，文件长度将增加，在以前的文件尾端和新的文件尾端之间的数据将读作0
文件系统
为了说明文件链接的概念，先介绍unix文件系统的基本结构，同时了解i节点和指向i节点的目录项之间的区别也是有益的。
传统的基于BSD的UNIX文件系统（UFS），其是以Berkeley快速文件系统为基础的。
我们可以把一个磁盘分成一个或多个分区。每个分区可以包含一个文件系统。i节点是固定长度的记录项，包含有关文件的大部分信息。






















上图介绍较为详细的柱面组的i节点和数据块部分。
1.在上图中有两个目录项指向同一个i节点。每个i节点中都有一个链接计数，其值是指向该i节点的目录项数。只有当链接计数减少至0时，才可删除该文件，释放该文件占用的数据块。因此，“解除对一个文件的链接”操作并不意味着“释放该文件占用的磁盘块”；同时，删除一个目录项的函数被称为unlink，而不是delete。在stat结构中，链接计数包含在st_nlink成员中，其基本系统数据类型是nlink_t。这种链接类型称为硬链接。
2.另一种链接类型称为符号链接。符号链接文件的实际内容包含了该符号链接所指向的文件的名字。

在上面的例子中，目录项中的文件名是lib，而在该文件中包含了7个字节的数据usr/lib。
3.i节点包含了文件有关的所有信息：文件类型、文件访问权限位、文件长度和指向文件数据块的指针等。stat结构中的大多数信息都取自i节点。只有两项重要数据存放在目录项中：文件名和i节点编号。i节点编号的数据类型是ino_t。
4.因为目录项中i节点编号指向同一文件系统的相应i节点，一个目录项不能指向另一个文件系统的i节点。
5.当在不更改文件系统的情况下为一个文件重命名时，该文件的时机内容并未移动。只需构造一个指向现有i节点的新目录项，并删除老的目录项。链接计数不会改变。为将文件/usr/lib/foo重命名为/usr/foo，如果目录/usr/lib和/usr在同一文件系统中，则文件foo的内容无需移动。
解释一下目录文件的链接计数字段，举例说明构造一个新目录：
mkdir testdir











上图显式地显式了.和..目录项。编号为2549的i节点，其类型字段表示它是一个目录，链接计数为2。任何一个叶目录的链接计数总是2，数值2来自于命名该目录（testdir）的目录项以及在该目录中的.项（有2个目录项指向2549）。编号为1267的i节点，其类型字段表示它是一个目录，链接计数大于等于3：一个命名它的目录项（并未表示出来），第二个是在该目录中的.项，第三个是在其子目录testdir中的..项（有3个目录项指向1267）。注意，在父目录中的每一个子目录都使该父目录的链接计数增加1。
函数link、linkat、unlink、unlinkat和remove
任何一个文件可以有多个目录项指向其i节点。创建一个指向现有文件的链接的方法是使用link函数或linkat函数。
int link(const char *existingpath, const char *newpath);
int linkat(int efd, const char *existingpath, int nfd, const char *newpath, int flag);
创建一个新目录项newpath，引用现有文件existingpath。如果newpath已经存在，则返回出错。只创建newpath中的最后一个分量，路径中的其他部分应当已经存在。
对于linkat函数，现有文件是通过efd和existingpath参数指定的，新的路径名通过nfd和newpath参数指定的。默认情况下，如果两个路径名中的任一个是相对路径，那么它需要通过相对于对应的文件描述符进行计算。如果两个文件描述符中的人一个设置为AF_FDCWD，那么相应的路径名就通过相对于当前目录进行计算。如果任一路径名是绝对路径，相应的文件描述符参数就会被忽略。
当现有文件是符号链接时，由flag参数来控制linkat函数是创建指向现有符号链接的链接还是创建指向现有符号链接所指向的文件的链接。如果在flag参数中设置了AT_SYMLINK_FOLLOW标志，就创建指向符号链接目标的链接。如果这个标志被清除了，则创建一个指向符号链接本身的链接。
创建新目录项和增加链接计数应当是一个原子操作。硬链接可能形成循环，因此，很多文件系统实现不允许对于目录的硬链接。调用unlink函数可以删除一个现有的目录项。
int unlink(const char *pathname);
int unlinkat(int fd, const char *pathname, int flag);
这两个函数删除目录项，并将由pathname所引用文件的链接计数减1。如果对该文件还有其他链接，则仍可通过其他链接访问该文件的数据。如果出错，则不对该文件做任何更改。
为了解除对文件的链接，必须对包含该目录项的目录具有写和执行权限。如果对该目录设置粘着位，则对该目录必须具有写权限，并且具备下面三个条件之一：拥有该文件；拥有该目录；具有超级用户权限。
只有当链接计数达到0时，该文件的内容可被删除。另一个条件也会阻止删除文件的内容——只要进程打开了该文件，其内容不能删除。关闭一个文件时，内核首先检查打开该文件的进程个数；如果计数达到0，内核再去检查其链接计数；如果计数也是0，那么删除该文件的内容。
unlink的这种特性经常被程序用来确保即使是在程序崩溃时，它所创建的临时文件也不会遗留下来。进程用open或creat创建一个文件，然后调用unlink，因为该文件仍是打开的，所以不会将其内容删除。只有当进程关闭该文件或终止时，该文件的内容才被删除。
如果pathname是符号链接，那么unlink删除该符号链接，而不是删除该链接所引用的文件。给出符号链接名的情况下，没有一个函数能删除有该链接所引用的文件。
remove函数解除对一个文件或目录的链接。对于文件，remobe的功能与unlink相同；对于目录，remove的功能与rmdir相同。
函数rename和renameat
rename和renameat函数可以重命名文件或目录。
oldname可以是文件、目录、符号链接，当newname已经存在时的情况：
1.如果oldname指的是一个文件而不是目录，那么为该文件或符号链接重命名。在这种情况下，如果newname已存在，则它不能引用一个目录。如果newname已存在，而且不是一个目录，则先将该目录项删除然后将oldname重命名为newname。对包含oldname的目录以及包含newname的目录，调用进程必须具有写权限，因为将更改这两个目录。
2.如若oldname指的是一个目录，那么为该目录重命名。如果newname已存在，则它必须引用一个目录，而且该目录必须应当是一个空目录。空目录指的是该目录中只有.和..项。如果newname存在，且是一个空目录，则先将其删除，然后将oldname重命名为newname。另外，当为一个目录重命名时，newname不能包含oldname作为其路径前缀。例如，不能将/usr/foo重命名为/usr/foo/testdir，因为旧名字是新名字的路径前缀，因而不能将其删除。
3.如果oldname或newname引用符号链接，则处理的是符号链接本身，而不是它所引用的文件。
4.不能对.和..重命名。
5.作为一个特例，如果oldname和newname引用同一文件，则函数不做任何更改而成功返回。
如果newname已经存在，则调用进程对它需要有写权限。另外，调用进程将删除oldname目录项，并可能要创建newname目录项，所以它需要对包含oldname及包含newname的目录具有写和执行权限。
符号链接
符号链接是对一个文件的间接指针，与硬链接不同。硬链接直接指向文件的i节点。引入符号链接的原因是为了避开硬链接的一些限制。
1.硬链接通常要求链接和文件位于同一文件系统中；
2.只有超级用户才能创建指向目录的硬链接。
对符号链接以及它指向何种对象并无任何文件系统限制，任何用户都可以创建指向目录的符号链接。符号链接一般用于将一个文件或整个目录结构移到系统中另一个位置。
当使用以名字引用文件的函数时，应该了解该函数是否处理符号链接。也就是该函数是否跟随符号链接到达它所链接的文件。如若该函数具有处理符号链接的更，则其路径名参数引用由符号链接指向的文件。否则，一个路径名蚕食引用链接本身，而不是由该链接指向的文件。






ln –s ../foo foo/testdir
以上命令造成图4-18中的循环。这样一个循环很容易消除：因为unlink并不跟随符号链接，所以可以unlink文件foo/testdir。但是如果创建了一个构成这种循环的硬链接，那么就难消除。
用open打开文件时，如果传递给open函数的路径名指定了一个符号链接，那么open跟随此链接到达所之低昂的文件。
创建和读取符号链接
symlink或symlinkat函数可以创建符号链接。
int symlink(const char *actualpath, const char *sympath);
int symlinkat(const char *actualpath, int fd, const char *sympath);
函数创建了一个指向actualpath的新目录项sympath。在创建此符号链接时，并不要求actualpath以及存在。并且，actualpath和sympath并不需要位于同一文件系统中。
symlinkat函数和symlink函数类似，但是sympath参数根据相对于打开文件描述符引用的目录进行计算。如果sympath参数指定的是绝对路径或者fd参数设置了AT_FDCWD值，那么symlinkat就等于symlink函数。
readlink和readlinkat函数可以打开链接本身，并读该链接中的名字。
文件的时间
每个文件属性所保存的实际精度依赖于文件系统的实现。每个文件维护3个时间字段：件数据的最后访问时间、文件数据的最后修改时间、i节点状态的最后更改时间。
注意，修改时间和状态更改时间之间的却别。修改时间是文件内容最后一次被修改的时间。状态更改时间是该文件的i节点最后一次被修改的时间。
系统管理员常常使用访问时间来删除在一定时间范围内没有被访问过的文件。同时，修改时间和状态更改时间可被用来归档那些内容已经被修改或i节点已经被更改的文件。
函数futimens、utimensat和utimes
一个文件的访问和修改时间可以用以下几个函数更改。futimens、utimensat函数可以指定纳秒级精度的时间戳。用到的数据结构是与stat函数族相同的timespec结构。
int futimens(int fd, const struct timespec times[2]);
int utimensat(int fd, const char *path, const struct timespec times[2], int flag);
这两个函数的times数组参数的第一个元素包含访问时间，第二个元素包含修改时间。这两个时间值是日历时间，这是自特定时间以来所经过的秒数。不足秒的部分用纳秒表示。
时间戳可以按下列4中方式之一进行指定：
1.如果times参数是一个空指针，则访问时间和修改时间两者都设置为当前时间；
2.如果times参数指向两个timespec结构的数组，任一数组元素的tv_nsec字段的值为UTIME_NOW，相应的时间戳就设置为当前时间，忽略相应的tv_sec字段；
3.如果times参数指向两个timespec结构的数组，任一数组元素的tv_nsec字段的值为UTIME_OMIT，相应的时间戳保持不变，忽略相应的tv_sec字段；
4. 如果times参数指向两个timespec结构的数组，且tv_nsec字段的值既不是UTIME_NOW也不是UTIME_OMIT；在这种情况下，相应的时间戳设置为相应的tv_sec和tv_nsec字段的值。
执行这些函数所要求的优先权取决于times参数的值：
1.如果times是一个空指针，或者任一tv_nsec字段为UTIME_NOW，则进程的有效用户ID必须等于该文件的所有者ID；进程对该文件必须具有写权限，或者进程是一个超级用户进程。
2.如果times是非空指针，并且任一tv_nsec字段的值既不是UTIME_NOW也不是UTIME_OMIT，则进程的有效用户ID必须等于该文件的所有者ID，或者进程必须是一个超级用户进程。对文件只具有写权限是不够的；
3.如果times是非空指针，并且两个tv_nsec字段的值都为UTIME_OMIT，就不执行任何的权限检查。
futimens函数需要打开文件来更改它的时间，utimensat函数提供了一种使用文件名更改文件时间的方法。
函数mkdir、mkdirat和rmdir
mkdir、mkdirat函数创建目录，用rmdir函数删除目录。
int mkdir(const char *pathname, mode_t mode);
int mkdirat(int fd, const char *pathname, mode_t mode);
这两个函数创建一个新的空目录，其中.和..目录项是自动创建的。所创建的文件访问权限mode由进程的文件模式创建屏蔽字修改。常见的错误是指定与文件相同的mode。但是，对于目录通常至少设置一个执行权限位，以允许访问该目录中的文件名。
mkdirat函数与mkdir函数类似。
用rmdir函数可以删除一个空目录，空目录是只包含.和..这两项的目录。如果调用rmdir函数使目录的链接计数成为0，并且也没有其他进程打开此目录，则释放由此目录占用的空间。如果在链接计数达到0时，有一个或多个进程打开此目录，则在此函数返回前删除最后一个链接及.和..项。另外，在此目录中不能再创建新问价。但是，在最后一个进程关闭它之前并不释放此目录。
读目录
对某个目录具有访问权限的任一用户都可以读该目录，但是，为防止文件系统产生混乱，只有内核才能写目录。一个目录的写权限位和执行权限位决定了在该目录中能否创建新文件以及删除文件，他们并不表示能否写目录本身。
fdopendir函数可以把打开文件描述符转换成目录处理函数需要的DIR结构。
DIR结构是一个内部结构，opendir、fdopendir、readdir、rewinddir、closedir、telldir、seekdir等函数用这个内部结构保存当前正在被读的目录的有关信息，其作用类似于FILE结构。FILE结构由标准I/O库维护。
函数chdir、fchdir和getcwd
每个进程都有一个当前工作目录，此目录是搜索所有相对路径名的起点。当用户登录到unix系统时，其当前工作目录通常是用户的起始目录。当前工作目录是进程的一个属性，其实目录则是登录名的一个属性。
进程调用chdir或fchdir函数可以更改当前工作目录：
int chdir(const char *pathname);
int fchdir(int fd);
以上两个函数分别用pathname或打开文件描述符来指定新的当前工作目录。因为当前目录是进程的一个属性，所以它只影响调用chdir的进程本身，而不影响其他进程。
因为内核必须维护当前工作目录的信息，所以我们应能获取其当前值。但是，内核为每个进程只保存指向该目录v节点的指针等目录本身的信息，并不保存该目录的完整路径名。
getcwd函数可以通过当前目录中的..项查找当前工作目录完整的绝对路径名。
chdir跟随符号链接，改变当前目录。getcwd获取当前目录的绝对路径。fchdir 通过fd返回当前目录。
设备特殊文件
1.每个文件系统所在的存储系统都由主、次设备号表示。设备号所用的数据类型是基本系统数据类型dev_t。主设备号标识设备驱动程序，有时编号为与其通信的外设板；次设备号标识特定的子设备。一个磁盘驱动器经常包含若干个文件系统。在同一磁盘驱动器上的各文件系统通常具有系统的主设备号，但是次设备号却不同。
2.我们通常是用两个宏major和minor来访问主、次设备号。
3.系统中与每个文件名关联的st_dev值是文件系统的设备号，该文件系统包含了这一文件名以及其对应的i节点。
4.只有字符特殊文件和块特殊文件才有st_dev值。此值包含实际设备的设备号。
文件访问权限位小结










第5章  标准I/O库
流和FILE对象
在第3章中，所有I/O函数都是围绕文件描述符的。当打开一个文件时，即返回一个文件描述符，然后改文件描述符就用于后续的IO操作。然而，对于标准IO库，他们的操作时围绕流来进行的。当标准IO库打开或创建一个文件时，我们已使一个流与一个文件相关联。
对于ASCII字符集，一个字符用一个字节表示。对于国际字符集，一个字符可用多个字节表示。标准I/O文件流可用于单字节或多字节字符集。流的定向决定了所读、写的字符时单字节还是多字节的。当一个流最初被创建时，它并没有定向。如若在未定向的流上使用多字节IO函数，则将该流设置为宽定向的。若在未定向的流上使用一个单字节IO函数，则将该流的定向设为字节定向的。只有两个函数可改变流的定向。freopen函数清除一个流的定向；fwide函数可用于设置流的方向。
根据mode参数的不同值，fwide函数执行不同的工作：
1.如若mode参数值为负，fwide将试图使指定的流是字节定向的；
2.如若mode参数为正，fwide将试图使指定的流是宽定向的；
3.如若mode参数为0，fwide将不试图设置流的定向，但返回标识该流定向的值。
当打开一个流时，标准IO函数fopen返回一个指向FILE对象的指针。该对象通常是一个结构，它包含了标准IO库为管理该流需要的所有信息，包括用于实际IO的文件描述符、指向用于该流缓存区的指针、缓存区的长度、当前在缓存区中的字符数以及出错标志等。
应用程序没有必要检验FILE对象，为了引用一个流，需将FILE指针作为参数传递给每个标准IO函数。本书称FILE对象的指针为文件指针。
标准输入、标准输出和标准错误
对一个进程预定义了3个流，并且这3个流可以自动地被进程使用：标准输入、标准输出和标准错误；这些流引用的文件与文件描述符所引用的相同。这3个标准IO流通过预定义文件指针stdin、stdout、stderr加以引用。这3个文件指针定义在头文件<stdio.h>中
缓冲
标准IO库通过缓冲的目的是尽可能减少使用read和write调用的次数。它也对每个IO流自动地进行缓冲管理，从而避免了应用程序需要考虑这一点所带来的麻烦。
标准IO提供了以下3中类型的缓冲：
1.全缓冲。在这种情况下，在填满标准IO缓存区后才举行实际IO操作。对于驻留在磁盘上的文件通常是由标准IO库实施全缓冲的。在一个流上执行第一次IO操作时，相关标准IO函数通常调用malloc获得需使用的缓存区。
术语冲洗说明标准I/O缓存区的写操作。缓存区可由标准IO例程自动地冲洗，或者可以调用函数fflush冲洗一个流。值得注意的是，在unix环境中，flush有两种意思。在标准IO库方面，flush意味着将缓冲区中的内容写到磁盘上。在终端驱动程序方面，flush表示丢弃已存储在缓冲区中的数据。
2.行缓冲。在这种情况下，当输入和输出中遇到换行符时，标准IO库执行IO操作。这允许我们一次输出一个字符（fputc），但只有在写了一行之后才举行实际IO操作。当流涉及一个终端时，通常使用行缓冲。
对于行缓冲有两个限制。第一，因为标准IO库用来收集每一行的缓存区的长度是固定的，所以只要填满了缓冲区，那么即使还没有写一个换行符，也进行IO操作。第二，任何时候只要通过标准IO库要求从（a）一个不带缓冲的流，或者（b）一个行缓冲的流（从内核请求需要数据）得到输入数据，那么就会冲洗所有行缓冲输出流。在（b）中带了一个在括号中的说明，其理由是，所需的数据可能已在该缓冲区中，它并不要求一定从内核读数据。很明显，从一个不带缓冲的流中输入需要从内核获得数据。
3.不带缓冲。标准IO库不对字符进行缓冲存储。标准错误流stderr通常是不带缓冲的。
但是，这并没有告诉我们如果标准输入和标准输出指向交互式设备时，他们是不带缓冲的还是行缓冲的，以及标准错误是不带缓冲的还是行缓冲的。很多系统默认使用下列类型的缓冲：
1.标准错误是不带缓冲的；
2.若是指向终端设备的流，则是行缓冲的；否则是全缓冲的。
int setbuf(FILE *restrict fp, char *restrict buf);
int setvbuf(FILE *restrict fp, char *restrict buf, int mode, size_t size);
以上两个函数可以更改缓冲类型。这些函数一定要在流已被打开后调用，而且也应在对该流执行任何一个其他操作之前调用。
可以使用setbuf函数打开或关闭缓冲机制。为了带缓冲进行IO，参数buf必须指向一个长度为BUFSIZE的缓存区。通常在此之后该流就是全缓冲的，但是如果该流与一个终端设备相关，那么某些系统也可将其设置为行缓冲的。为了关闭缓冲，将buf设置为NULL。
使用setvbuf，我们可以精确地说明所需的缓冲类型。这是用mode参数实现的：_IOFBF（全缓冲）；_IOLBF（行缓冲）；_IONBF（不带缓冲）。如果指定一个不带缓冲的流，则忽略buf和size参数。如果指定全缓冲或行缓冲，则buf和size可选择地指定一个缓冲区及其长度。如果该流是带缓冲的，而buf是NULL，则标准IO库将自动地为该流分配适当长度的缓存区。适当长度指的是由常量BUFSIZE所指定的值。
要了解，如果在一个函数内分配一个自动变量类的标准IO缓冲区，则从该函数返回之前，必须关闭该流。另外，某些实现将缓冲区的一部分用于存放它自己的管理操作信息，所以可以存放在缓冲区中的实际数据字节数少于size。一般而言，应由系统选择缓冲区的长度，并自动分配缓冲区。在这种情况下关闭此流时，标准IO库将自动释放缓冲区。
fflush函数可以强制冲洗一个流，此函数使该流所有未写的数据都被传送至内核。作为一个也是情形，如若fp是NULL，则此函数导致所有输出流被冲洗。
打开流
FILE  *fopen(const char *restrict pathname, const char *restrict type);
FILE  *freopen(const char *restrict pathname, const char *restrict type, FILE *restrict fp);
FILE  *fdopen(int fd, const char *type);
以上3个函数打开一个标准IO流，区别如下：
1. fopen函数打开路径名为pathname的一个指定的文件；
2.freopen函数在一个指定的流上打开一个指定的文件，如若该流已经打开，则先关闭该流。若该流已经定向，则使用freopen清除该定向。此函数一般用于将一个指定的文件打开一个预定义的流：标准输入、标准输出或标准错误。
3.fdopen函数取一个已有的文件描述符，并使一个标准IO流与该描述符相结合。此函数常用于由创建管道和网络通信通道函数返回的描述符。因为这些特殊类型的文件不能用标准IO函数fopen打开，所以我们必须先调用设备专用函数以获得一个文件描述符，然后用fdopen使一个标准IO流与该描述符相结合。
type参数指定对流IO流的读、写方式。使用字符b作为type的一部分，这使得标准IO系统可以区分文本文件和二进制文件。因为UNIX内核并不对这两种文件进行区分，所以在UNIX系统环境下指定字符b作为type的一部分实际上并无作用。
若流应用的是终端设备，则该流是行缓冲，否则按系统默认，流被打开时是全缓冲。一旦打开了流，那么在对该流执行任何操作之前，如果希望，泽科使用倩姐所属的setbuf和setvbuf改变缓冲的类型。
调用fclose函数关闭一个打开的流。在该文件被关闭之前，冲洗缓冲中的输出数据。缓冲区中的任何输入数据被丢弃。如果标准IO库为该流自动分配了一个缓冲区，则释放此缓冲区。
当一个进程正常终止时，则所有带有未写缓冲数据的标准IO流都被冲洗，所有打开的标准IO流都被关闭。
读和写流
一旦打开了流，则可在3中不同类型的非格式化IO中进行选择，对其进行读、写操作：
1.每次一个字符的IO。一次读、写一个字符，如果流是带缓冲的，则标准IO函数处理所有缓冲。
2.每次一行的IO。如果想要一次读或写一行，则使用fgets和fputs。每行都以一个换行符终止。当调用fgets时，应说明能处理的最大行长。
3.直接IO。fread和fwrite函数支持这种类型的IO。每次IO操作读或写某种数量的对象，而每个对象具有指定的长度。这两个函数常用于从二进制文件中每次读或写一个结构，
每次一字符IO
输入函数：可用于一次读取一个字符的函数getc、fgetc、getchar函数。在大多数实现中，为每个流在FILE对象中维护了两个标志：出错标志和文件结束标志。调用clearerr可以清除这两个标志。从流中读取数据之后，可以调用unget将字符在压送回流中。压送回到流中的字符可以从流中读取，但是读出字符的顺序与压送回的顺序相反。回送的字符不一定必须是上一次读到的字符。
输出函数：相对于输入函数都有一个输出函数putc、fputc、putchar函数
每次一行IO
fgets和gets函数每次输入一行，这两个函数都指定了缓冲区的地址，读入的行将送入其中。gets从标准输入读，而gets则从指定的流读。
对于fgets，必须hiding缓冲区的长度n，此函数一直读到下一个换行符为止，但是不超过n-1个字符，读入的字符被送入缓冲区。该缓冲区以null字节结尾。如若该行包括最后一个换行符的字符数超过n-1，那么fgets值放回一个不完整的行，但是缓冲区总是以null字节结尾。对fgets的下一次调用会继续读该行。
对于gets函数，不推荐使用，其问题是调用者在使用gets时不能指定缓冲区的长度。这样可能造成缓冲区溢出，写到缓冲区之后的存储空间中，从而产生不可预料的后果。
每次输出一行的函数有fputs和puts。
标准IO的效率
标准IO库与直接调用read和write函数相比并不慢很多。
二进制IO
如果进行二进制IO操作，那么我们更愿意一次读或写一个完整的结构。如果使用getc或putc读写一个结构，那么必须循环通过整个结构，每次循环处理一个字节，一次读或写一个字节，麻烦且费事。同时，数据中可能有null字节或换行符。因此，fread、fwrite函数可以执行二进制IO操作。这两个函数放回读或写的对象数。
对于读，如果出错或到达文件尾端，则此数字可以少于要求读的数目。在这种情况下，应调用ferror或feof以判断纠结是哪一种情况。
对于写，如果返回的值少于所要求的数目，则出错。
使用二进制IO需要在同一系统上读取已写数据。在这种环境下，这两个函数可能不能正常工作，其原因是：
1.同一个结构中，同一成员的偏移量可能随编译程序和系统的不同而不同；
2.用来存储多字节整数和福地安置的二进制格式在不同的系统结构间也可能不同。
定位流
有3中方法定位标准IO流：
1.ftell和fseek函数，假定文件的位置可以存放在一个长整型中；
2.ftello和fseek哦函数，使文件偏移量可以不必一定使用长整型；
3.fgetpos和fsetpos函数，使用一个抽象类型fpos_t记录文件的位置。
对于一个二进制文件，其文件位置指示器是从文件开始位置开始度量，并以字节为度量单位的，ftell用于二进制文件时，其返回值就是这种字节位置。为了用fseek定位一个二进制文件，必须制定一个字节offset，以及解释这种偏移量的方式。SEEK_SET表示从文件的起始位置开始，SEEK_CUR表示从当前文件位置开始，SEEK_END表示从文件的尾端开始。
对于文本文件，他们的文件当前位置可能不以简单的字节偏移量来度量。为了定位一个文本文件，起始位置的属性一定要是SEEK_SET。而且offset只能有两个值：0，或是对该文件的ftell所返回的值。使用rewind函数也可将一个流设置到文件的起始位置。
格式化IO
格式化输出
printf、fprintf、dprintf、sprintf、snprintf函数
printf将格式化数据写到标准输出；fprintf写至指定的流，dprintf写至指定的文件描述符，sprintf将格式化的字符送入数组buf中。sprintf在该数组的尾端自动加上一个null字节，但该字符不包括在放回值中。
vprintf、vfprintf、vdprintf、vsprintf、vsnprintf函数为printf族的变态，只是存在可变参数。
格式化输入
scanf、fscanf、sscanf函数执行格式化输入处理。scanf族用于分析输入字符串，并将字符序列转换成指定类型的变量。在格式之后的各参数包含了变量的地址，用转换结果对这些变量赋值。
格式说明控制如何转换参数，以便对他们赋值。转换说以%字符开始，除转换说明和空白字符外，格式字符串中的其他字符必须与输入匹配。若有一个字符不匹配，则停止后续处理，不再读输入的其余部分。
vscanf、vfscanf、vsscanf函数含有可变长度参数表。
实现细节
每个标准IO流都有一个与之相关联的文件描述符，可以对一个流调用fileno函数已获得其描述符。如果调用dup或fctnl等函数，则需要此函数。
系统默认：当标准输入、输出连至终端时，他们是行缓冲的。行缓冲的长度是1024个字节。这只是行冲的长度。如果将2048字节的行写到标准输出，则要进行两次write系统调用。当将标准输入、输出这两个流重定向到普通文件时，它们是全缓冲的，其缓冲区长度是该文件系统有限选用的IO长度。从中也可看到，标准错误如它所掩盖的那样是不带缓冲的，而普通文件按系统默认是全缓冲的。
临时文件
ISO C标准IO库提供tmpnam和tmpfile函数可以帮助创建临时文件。
tmpnam函数产生一个与现有文件名不同的一个有效路径名字符串，每次调用它时，都产生不同的路径名，最多调用次数为TMP_MAX。若参数ptr是NULL，则所产生的路径名存放在一个静态区中，指向该静态区的执政作为函数值返回。然后调用tmpnam时，会重写该静态区。若ptr不是NULL，则认为它应该指向长度至少为L_tmpnam个字符的数组。所产生的路径名存放在该数组中，ptr也作为函数值返回。
tmpfile创建一个临时二进制文件，在关闭该文件或程序结束时将自动删除这种文件。
SUS提供另外两个函数mkdtemp和mkstemp来处理临时文件。
mkdtemp函数创建一个目录，该目录有一个唯一的名字；mkstemp函数创建一个文件，该文件有一个唯一的名字。名字通过参数进行选择。与tempfile不同，mkstemp创建的临时文件并不会自动删除。如果希望从文件系统命名空间中删除该文件，必须自己对它解除链接。
内存流
标准IO库把数据缓存在内存中，因此每次一字符和每次一行的IO更有效。我们也可以调用setbuf或setvbuf函数让IO库使用自己的缓冲区。这就是标准IO流，虽然仍使用FILE指针进行访问，但是并没有底层文件。多有的IO都是通过在缓冲区与主存之间来回传送字节来完成的。即便这些流看起来像文件流，他们的某些特征使其更适用于字符串操作。
fmemopen函数允许调用者提供缓冲区用于内存流：buf参数指向缓冲区的开始位置，size参数指定了缓冲区大小的字节数。如果buf参数为空，fmemopen函数分配size字节数的缓冲区。在这种情况下，当流关闭时缓冲区会被释放。
用于创建内存流的其他两个函数分别是open_memstream和open_wmemstream函数。open_memstream函数创建的流是面向字节的，open_wmemstream函数创建的流是面向款字节的。与fmemopen函数不同在于：
1.创建的流只能写打开；
2.不能指定自己的缓冲区，但可以分别通过bufp和sizep参数访问缓冲区地址和大小；
3.关闭流后需要自行释放缓冲区；
4.对流添加字节会增加缓冲区大小。
第6章  系统数据文件和信息
口令文件
unix系统的口令文件定义在pwd.h的passwd结构中。口令文件是/etc/passwd。
POSIX定义了两个获取口令文件项的函数getpwuid和getpwnam，在给出用户登录名和数值用户ID后，这两个函数就能查看相关项。
getpwuid函数有ls程序使用，它将i节点中的数字用户ID映射为用户登录名，在键入登录名时，getpwnam函数由login程序使用。
这两个函数都返回指向passwd结构的指针，该结构已由这两个函数在执行时填入信息。passwd结构通常是函数内部静态变量，只要调用任意相关函数，其内容就会被重写。
查看整个口令文件的函数：getpwent、setpwent、endpwent
调用getpwent时，它返回口令文件中的下一个记录项。如同上面所述的getpwuid和getpwnam函数一样，返回指向passwd结构的指针。每次调用此函数时都重写该结构。在第一次调用该函数时，它打开它所使用的各个文件。在使用本函数时，对口令文件中各个记录项的安排顺序并无要求。某些系统参与散列算法对/etc/passwd文件中各项排序。
函数setpwent反绕它所使用的文件，endpwent则关闭这些文件。在使用getpwent查看完口令文件后，一定要调用endpwent关闭这些文件。
阴影口令
加密口令是经单向加密算法处理过的用户口令副本。因为此算法时单向的，所以不能从加密口令猜测原来的口令。
对于一个加密口令，找不到一种算法可以将其反变换到明文口令。但是可以对口令进行猜测，将猜测的口令进单向算法变换成加密形式，然后将其余用户的加密口令相比较。如果用户口令是随机算则的，那么这种方法并不是很有用。但是用户往往以非随机方式选择口令。一个进程重复的实验是先得到一份口令文件，然后用试探方法猜测口令。
为使企图这样做的人难以获得原始的加密口令，现在，某些系统将加密口令存放在另一个通常称为阴影口令的文件中。该文件至少要包含用户名和加密口令。与该口令相关的其他信息也存放在该文件中。最重要的是用户登录名和加密口令。
阴影口令文件不应是一般用户可以读取的，仅有少数几个程序需要访问加密口令，如login和passwd，这些程序常常是设置用户ID为root的程序。有了阴影口令后，普通口令文件/etc/passwd可由用户自由读取。
组文件
unix组文件包含组名，加密口令，数值组ID，指向各用户名，指针的数组。这些字段包含在grp.h中所定义的group结构中。
getgrfid和getgrnam函数可以用来查看组名或数值组ID。返回指向一个静态变量的指针，每次调用需要重写静态变量。
getgrent、setgrent、endgrent函数可以搜索整个组文件。
附属组ID
在unix系统中，对组的使用以及做了些更改。如今，我们不仅可以属于口令文件记录项中组ID所对应的组，也属于多至16个另外的组。文件访问权限检查相应被修改为：不仅将进程的有效组ID与文件的组ID相比较，而且也将所有附属组ID与文件的组ID进行比较。
使用附属组ID的优点是不必再显示地经常更改组。一个用户会参与多个项目，因此也就要同时属于多个组，此类情况是常有的。
getgroups、setgroups、initgroups函数可以获取和设置附属组ID。
getgroups将进程所属用户的各附属组ID填写到数组grouplist中，填写入该数组的附属组ID数最多为gidsetsize个。实际填写到数组中的附属组ID数由函数返回。作为一种特殊情况，如若gidsetsize为0，则函数值放回附属组ID数，而对数组grouplist则不做修改。
setgroups可由超级用户调用以便为调用进程设置附属组ID表。grouplist是组ID数组，而ngroups说明了数组中的元素数。ngroups的值不能大于NGROUPS_MAX。
通常，只有initgroups函数调用setgroups，intgroups读整个组文件，然后对username确定其组的成员关系。然后，它调用setgroups，以便为该用户初始化附属组ID表。因为initgroups要调用setgroups，所以只有超级用户才能调用initgroups。
实现区别
linux和solaris支持阴影口令文件；freebsd和mac os x则以不同方式存储加密口令字。本书所涉及的4种平台如何存储用户和组信息。






其他数据文件
BSD网络软件有一个记录各网络服务器所提供的数据文件（/etc/services），有一个记录协议信息的数据文件（/etc/protocols），还有一个则是记录网络信息的数据文件（/etc/networks），接口与处理口令文件和组文件相似。
一般情况下，对每个数据文件至少有3个函数
1.get函数：读下一个记录，如果需要，还会打开该文件。此种函数通常返回指向一个结构的指针。当已到达文件尾端时返回空指针。大多数get函数返回指向一个静态存储类结构的指针，如果要保存期内容，则需要复制它。
2.set函数：打开相应数据文件，然后反绕该文件。如果希望在相应文件起始处开始处理，则需要复制它。
3.end函数：关闭相应数据文件。在对相应数据文件的读写操作后，总应调用此函数以关闭所有相关文件。
登录账户记录
大多数unix系统都提供下列两个数据文件：utmp文件记录当前登录到系统的各个用户；wtmp文件跟踪各个登录和注销时间。
登录时，login程序填写此类型结构，然后将其写入utmp文件中，同时也将添加到wtmp文件中。注销时，init进程将utmp文件中相应的记录擦除，并将一个新记录添写到wtmp文件中。在wtmp文件的注销记录中，ut_name字段清除为0。在系统再启动时，以及更改系统时间和日期的前后，都在wtmp文件中追加写特殊的记录项。who程序读取utmp文件，并以可读格式打印其内容。
系统标志
uname函数返回主机和操作系统有关的信息。通常用uname命令打印。
gethostname函数值返回主机名，该名字通常就是TCPIP网络上主机的名字。如果宿主机链接到TCPIP网络中，则此主机名通常是该主机的完整域名。
hostname命令可用来获取和设置主机名，主机名通常在系统自举时设置，它由/etc
、rc或init取自一个启动文件。
时间和日期例程
由UNIX内核提供的基本时间服务时计算自协调世界时这一特定时间以来经过的秒数。unix在这方面与其他操作系统的区别是：1.以协调统一时间而非本地时间计时；2.可自动进行转换，如变换到夏令时；3.将时间和日期作为一个量值保存。










time函数返回当前时间和日期；
clock_gettime函数可用于获取指定时钟的时间，返回的时间为秒和纳秒，可能比time函数得到更高角度的时间值；
clock_getres函数把参数tsp指向的timespec结构初始化为与clock_id参数对于的时钟精度；
clock_settime函数对特定的时钟设置时间；
gettimeofday函数提供更高的精度，以距特定时间的秒数的方式将当前时间存放在tp指向的timeval结构中，而该结构将当前时间表示为秒和微妙；
localtime和gmtime将日历时间转换成分解时间，并将这些存放在一个tm结构中。区别是：localtime将日历时间转换成本地时间，而gmtime则将日历时间转换成协调统一时间的年月日时分秒周日分解结构。
mktime函数以本地时间年月日等作为参数，将其转换成time_t的值。
strftime函数是一个类似于printf的时间值函数。
第7章  进程环境
main函数
c程序总是从main函数开始执行。main函数的原型是：
int main(int argc,char *argv[]);
其中argc是命令行参数的数目，argv是指向参数的各个指针所构成的数组。
当内核执行C程序时，在调用main前先调用一个特殊的启动例程。可执行程序文件将此启动例程指定为程序的其实位置（链接编辑器设置的），而链接编辑器则是由c编译器调用。启动例程从内核取得命令行参数和环境变量值，然后为按上述方式调用main函数做好安排。
进程终止
8中方式使得进程终止，其中5种为正常终止：从main返回、调用exit、调用_exit或_Exit、最后一个线程从其启动例程返回、从最后一个线程调用pthread_exit。异常终止有3种方式：调用abort、接到一个信号、最后一个线程对取消请求作出响应。
exit(main(argc,argv))使得从main返回后立即调用exit函数。
1.退出函数
exit、_exit、_Exit用于正常终止一个程序：_exit或_Exit立即进入内核，exit则先执行一些清理处理，然后返回内核。exit函数总是执行一个标准IO库的清理关闭操作：对于所有打开流调用fclose函数，造成缓冲中的所有数据都被冲洗（写到文件上）。
3个退出函数都有一个整型状态，称为终止状态（或退出状态）。大多数unix系统shell都提供检查进程终止状态的方法。如果调用这些函数不带终止状态，或mian执行了一个无返回值的return语句，或main没有声明返回类型为整型，则该进程的终止状态是未定义的。但是，若main的放回类型是整型，并且main执行到最后一条语句时返回，那么该进程的终止状态是0。
exit(0)等价于return(0)
对该程序进行编译，然后运行，则可见到其种植吗是随机的，如果在不同的系统上编译该程序，则可能得到不同的终止码。
2.函数atexit
一个进程可以登记多至32个函数，这些函数将由exit自动调用。我们称这些函数为终止处理程序，并调用atexit函数来登记这些函数。
int atexit(void (*func)(void));
其中，atexit的参数是一个函数地址，当调用此函数时无需向它传递任何参数，也不期望它返回一个值。exit调用这些函数的殊勋与他们登记时候的顺序相反。















命令行参数
当执行一个程序时，调用exec的进程可将命令行参数传递给该新程序。例如将所有命令行参数都回显到标准输出上。
环境表
每个程序都接收到一张环境表。与参数表一样，环境表也是一个字符指正数组，其中每个指针包含一个以null结束的C字符串的地址，环境变量environ则包含了该指针数组的地址，例如下图。










c程序的存储空间布局
C程序一直由下列几部分组成：
1.正文段：这是由CPU执行的机器指令部分，可共享；并且，频繁执行的程序在存储器中也只需要有一个副本，另外，正文段常常是只读的， 以防止程序由于意外而修改命令。
2.初始化数据段：通常将此段称为数据段，它包含了程序中需明确地赋初值的变量。例如，C程序中任何程序之外的声明：int maxcount = 99。
3.未始化的数据段。通常将此段称为bss段，在程序开始执行之前，内核将此段中的数据初始化为0或控制正。函数外的声明：long sum[100]。
4.栈：自动变量以及每次函数调用时所需保存的信息都存放在此段中。每次函数调用时，其放回地址以及调用者的环境信息都存放在此段中。然后最近被调用的函数在栈上为其自动和临时变量分配存储空间。通过以这种方式使用栈，C递归函数可以工作。地柜函数每次调用自身时，就用一个新的栈帧，因此一次函数调用实例中的变量及不会影响另一个函数调用实例中的变量。
5.堆：通常在堆中进行动态存储分配。












共享库
共享库是的可执行文件中不再需要包含公用的库函数，而只需要在所有进程都可引用的存储区中保存这种库例程的一个副本。程序第一次执行或者第一次调用某个库函数时，用动态链接方法将程序与共享库函数想链接。这减少了每个可执行文件的长度，但增加一些运行时间的开销。这种时间开销发生在该程序第一次被执行时，或者每个共享库函数第一次被调用时。共享库的另一个有点是可以用库函数的新版本代替老版本而无需对使用该哭的程序重新链接编译。
存储空间分配
malloc、calloc、realloc函数用于空间（堆）动态分配的函数：
1.malloc函数用于分配指定字节的存储区，初始值不确定；
2.calloc函数用于为指定数量指定长度的对象分配存储空间。该空间中的每一位都初始化为0；
3. realloc函数增加或减少以前分配区的长度。当增加长度时，可能需将以前分配区的内容一道另一个足够大的区域，以便在尾端提供增加的存储区，而新增区域内的初始值则不确定。
函数free释放参数ptr指向的存储空间。被释放的空间通常被送入可用的存储池，以后，可在调用上述4个分配函数时在分配。
环境变量
如同前述，环境字符串的形式是：
name=value
Unix内核并不查看这些字符串，他们的解释完全取决于各个应用程序。例如，shell使用了大量的环境变量。
ISO C定义了一个函数getenv，可以用其取环境变量值，但是该标准又称回家的内容是由实现定义的。此函数放回一个指针，指向value。我们有的那个使用getenv从环境中取一个指定环境变量的值，而不是直接访问environ。
除了获取环境变量值，有时也需要设置环境变量。我们可能希望改变现有变量的值，或者是增加新的环境变量。getenv、putenv、setenv、unsetenv、clearenv函数可以更改环境变量。
putenv函数将name=value的字符串，将其放到环境表中。如果那么一句存在，则先删除其原来的定义；
setenv函数将name设置为value，若name已经存在，如果可以更改则更改，否则不删除现有定义；
unsetenv函数删除name的定义。即使不存在这种定义也不算出错。









（1）如果修改一个现有的name：
a.如果新value的长度少于或等于现有value的长度，则只要将新字符串复制到源字符串所用的空间中；
b.如果新的value的长度大于原长度，则必须调用malloc为新字符串分配空间，然后将新字符串复制到该空间中，接着使环境表中针对name的指针指向新分配区。
（2）如果要增加一个新的name，则操作就更加复杂。首先，必须调用malloc为name=value字符串分配空间，然后将该字符串复制到此空间中。
a.如果这是第一次增加一个新name，则必须调用malloc为新的指针表分配空间。接着，将原来的环境表复制到新分配去，并指向新name=value字符串的指针存放在该指针表的表位，然后又将一个空指针存放在其后。最后使environ指向新指针表。如果原来的环境表位于栈顶之上，那么必须将此表移至堆中。但是，此表中的大多数指针仍指向栈顶之上的各name=value字符串。
b.如果这不是第一次增加一个新name，则可知以前已调用malloc在堆中为环境表分配了空间，所以只要调用realloc，以分配比原空间多存放一个指针的空间。然后指向新name=value字符串的指针存放在该表表尾，后面跟一个空指针。
函数setjmp和longjmp
在c中goto语句是不能跨越函数的，而执行这中类型跳转功能的是函数setjmp和longjmp。这两个函数对于处理发生在很深层嵌套函数调用中的出错情况是非常有用的。
在编写深层嵌套的程序时，如果最深层次的程序出现错误时，我们不得不以检查返回值的方式逐层返回，那么就会很难处理。解决这类的方法就是使用非局部函数setjmp和longjmp。非局部指的是，这不是由普通的C语言goto语句在一个函数内实施的跳转，而是在栈上跳过若干调用帧，返回到当前函数调用路径上的某个函数中。
在希望返回到的位置调用setjmp，在本例中，此位置在main函数中。因为我们直接调用该函数，所以其返回值为0。setjmp参数env的类型是一个特殊类型，这一数据类型是某种形式的数组，其中存放在调用longjmp时能用来恢复栈状态的所有信息。因为需在另一个函数中应用env变量，所有通常将env变量定义为全局变量。
当在深层函数中检查到一个错误时，调用longjmp函数，有两个参数：第一个就是调用setjmp时所用的env；第二个参数是具有非0值的val，将成为从setjmp出所返回的值。使用第二个参数的原因是对于一个setjmp可以有多个longjmp。在main函数中，setjmp的返回值就会是1或2，通过测试返回值就可判断造成返回的longjmp是哪个函数。
1.自动变量、寄存器变量和易失变量
当longjmp函数返回到mian函数时，多数实现并不回滚这些自动变量和寄存器变量的值。
2.自动变量的潜在问题
声明自动变量的函数研究返回后，不能再引用这些自动变量。
函数getrlimit和setrlimit
每个进程都有一组资源限制，其中一些可以用getrlimit和setrlimit函数查询和更改。对这两个函数的每一次调用都指定一个资源以及一个指向rlimit结构的指针。
在更爱资源限制时，要遵守以下3条规则：
1.任何一个进程都要将一个软限制值更改为小于等于其硬限制值；
2.任何一个进程都可降低其硬限制值，但是必须大于等于其软限制值。这种降低，对普通用户而言是不可逆转的；
3.只有超级用户进程可以提高硬限制值。
资源限制影响到调用进程并由其子进程进程。这就意味着，为了影响一个用户的所有后续进程，需将资源限制的设置构造在shell之中。
第8章  进程控制
进程标识
每个进程都有一个非负整型标识的唯一进程ID，因为进程是唯一的，所以进程用以其他标识符的一部分。进程ID也是可复用，并延迟复用。
系统中有专用进程。如ID为0的进程通常是调度进程，称为交换进程。该进程是内核的一部分，并不执行任何磁盘上的程序，为系统进程。进程为1通常是init进程，在自举过程结束时由内核调用。该进程在自举内核后启动一个unix系统。init进程不会终止，是一个普通的用户进程，但是以超级用户特权运行。每个unix系统实现都有它自己的一套提供操作系统服务的内核进程。
函数fork
一个现有的进程可以调用fork函数创建一个新进程。有fork创建的新进程被陈为子进程，fork函数被调用一次，但返回两次。两次返回区别是子进程返回是0，而父进程返回值是新建子进程的ID。将子进程ID返回给父进程的理由是：因为一个进程的子进程可以有多个，并且没有一个函数使一个进程可以获得其子进程的ID。给子进程返回0：一个进程只会有一个父进程，所有子进程总是可以调用getppid以获得其父进程的进程ID，并且ID为0 的进程已经确定。
子进程和父进程继续执行fork调用之后的命令。子进程是父进程的副本。父子进程共享正文段，但是不共享数据空间、堆、栈。如今，使用写时复制技术，数据空间、堆、栈有父子共享，这些共享的区域的访问权限改变为只读，在要修改这些区域时，内核只为修改区域块制作一个副本。
一般来说，在fork之后父子进程的执行时不确定的，取决于调度算法。如果父子进程之间需要相互同步，则要求某种形式的进程间通信。
文件共享
在重定向父进程的标准输出时，子进程的标准输出也被重定向。实际上，fork的一个特性是父进程的所有打开文件描述符都被复制到子进程中。父进程和子进程每个相同的打开描述符共享一个文件表项。重要的一点是，父进程和子进程共享文件偏移量。


















如果父子进程在写同一描述符指向的文件，但又没有任何形式的同步，那么他们那的输出会相互混乱。
在fork之后处理文件描述符有以下两种常见的情况：
1.父进程等待子进程完成。
2.父子进程各自执行不同的程序段。各自处理不同的文件描述符，互补干扰。通常是网络服务进程进程使用的。
除了打开文件之外，父进程的很多其他属性也由子进程集成，包括：
1.实际用户、组ID，有效用户、组ID；
2.附属组ID；
3.进程组ID；
4.会话ID；
5.控制终端；
6.设置用户ID标志和设置组ID标志；
7.当前工作目录；
8.跟目录；
9.文件模式创建屏蔽字；
10.信号屏蔽和安排；
11.文件描述符的关闭标志；
12.环境；
13.链接的共享存储段；
14.存储映像；
15.资源限制。
父子进程之间的区别如下：
1.fork的返回值；
2.进程ID；
3.父进程ID；
4.子进程是tms_*的值被设置为0；
5.子进程不继承父进程设置的文件锁；
6.子进程的未处理闹钟被清除；
7.子进程的未处理信号集设置为空集。
fork有以下两个用法：
1.一个父进程希望复制自己，使父进程和子进程同时执行不同的代码段；网络进程之间的请求和应答
2.一个进程要执行一个不同的程序。
函数vfork
vfork函数的调用序列和返回值与fork相同，但两者语义不同。
vfork函数用于创建一个新进程，而新进程的目的是exec一个新程序。vfork并不将父进程的地址空间完全复制到子进程中，因为子进程立即调用exec或exit，也就不会引用父进程的地址空间。在子进程调用exec或exit之前，它在父进程的空间运行。
vfork保证子进程先运行，在它调用exec或exit之后父进程才会调度运行，当紫禁城嗲用这两个函数时，父进程会恢复运行。
函数exit
进程有5种正常终止方式：
1.从main函数内执行return语句返回；
2.调用exit；ISO C定义：调用各种终止处理程序，关闭所有标准IO流。
3.调用_exit或_Exit；
4.最后一个线程从其启动例程执行teturn返回；该线程的返回值不用作进程的返回值。进程以终止状态0返回；
5.从最后一个线程调用pthread_exit。
异常终止有3种方式：
1.调用abort；
2.接到一个信号；信号可由进程吱声、其他进程或内核产生；
3.最后一个线程对取消请求作出响应。
不管进程如何终止，最后都执行内核中的同一段代码，为相应进程关闭所有打开描述符，是否它所使用的存储器等。
对上述任一一种终止情形，我们都希望终止进程能够通知其父进程它是如何终止的。对于3个终止函数，实现这一点的方法是，将其退出状态作为参数传送给函数。在异常终止情况下，内核产生一个指示其异常终止原因的终止状态。在任何情况下，该这种进程的父进程都能用wait或waitpid函数取得其终止状态。
当子进程退出时，父进程可以得知其终止状态。当父进程终止时，内核做个检查所有活动进程，以判断它是否使正要终止进程的子进程，若是，则子进程的父进程ID将会被更改为1（init进程ID）。
一个已经终止，但是其父进程尚未对其进行上后处理的进程被称为僵死进程。
init进程的子进程可能是自己fork的子进程，也可能是收养的进程。
函数wait和waitpid
当一个进程正常或异常终止时，内核向其父进程发送SIGCHD信号。因为子进程终止是个异步事件，所以这种信号也是内核向父进程发的异步通知，父进程可以选择忽略该信号，或者提供一个该信号发生时即被调用执行的函数。
调用wait或waitpid的进程可能发生以下事情：
1.如果其所有子进程都还在运行，则阻塞；
2.如果一个子进程已终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即放回；
3.如果它没有任何子进程，则立即出错返回。
如果进程由于接收到SIGCHLD信号而调用wait，我们期望wait会立即返回。否则可能会阻塞。
wait和waitpid函数的区别如下：
1.在一个子进程终止前，wait使其调用者阻塞，而waitpid有选项可以不阻塞；
2.waitpid并不等待在其调用之后的第一个终止子进程，它有若干个选项，可以控制它所等待的进程。调用者阻塞而它有多个子进程，则在其某一进程终止时，wait就立即返回。
这两个函数都有一个整型指针来记录子进程的终止状态。
waitpid函数提供了wait函数没有提供的3个功能：
1. waitpid可等待一个特定的进程，而wait则返回任意终止子进程的状态；
2. waitpid提供了一个wait的非阻塞版本；
3. waitpid通过设置可以支持作业控制。
函数waitid
SUS提供另一个终止状态的函数waitid，类似于waitpid，提供了更多的灵活性。
waitid允许一个进程指定要等待的子进程。但它使用两个单独的参数表示要等待的子进程所属的类型，而不是将此与进程ID或将进程组ID组合成一个参数。id参数的作用于idtype的值相关。






options参数是个标志的按位或运算。








函数wait3和wait4
大多数UNIX系统实现提供wait3和wait4，其参数允许内核返回由终止进程机器所有子进程使用的资源情况。资源统计信息包括用户CPU时间总量、系统CPU时间总量、缺页次数、接收到信号的次数等。
竞争条件
当多个进程都企图对共享数据进行某种处理，而最后结果取决于进程运行的顺序时，我们认为发生了竞争关系。
如果一个进程希望等待一个子进程终止，则它必须调用一个wait函数中的一个。如果需要等待期父进程终止，则可使用下列形式的循环：
while(getppid() != 1)
sleep(1);
这种轮询浪费CPU时间，因为调用者每隔1s都被唤醒，然后进行条件测试。为了避免竞争条件和轮询，在多个进程之间需要有某种形式的信号发送和接收的方法。在父子进程的关系中，在fork之后，父进程和子进程都有一些事情要做。
定义宏TELL_WAIT、TELL_PARENT、TELL_CHILD、WAIT_PARENT函数，作为信号的一种实现。调用这些函数可以使得父子进程交叉运行。
函数exec
当fork函数创建子进程后，子进程往往调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程执行的程序完全替换为新程序，而新程序则从其main函数开始执行。因为调用exec并不创建新进程，所以前后的进程ID并未改变。exec只是用磁盘上的新程序替换了当前进程的正文段、数据段、堆段和栈段。
有7中不同的exec函数可供使用，常常被陈为exec函数。用fork可以创建新进程，用exec可以执行初始化新进程。exit函数和wait函数处理终止和等待终止。
这些函数之间的第一个区别就是取路径名、文件名、文件描述符作为参数。当指定filename作为参数时：如果filename中包含/，则将其视为路径名；否则就按PATH环境变量，在它所指定的各目录中搜索可执行文件。












更改用户ID和更改组ID
在unix系统中，特权以及访问控制是基于用户ID和组ID。当程序需要增加特权，或需要访问当前并不允许访问的资源时，我们需要更换自己用户ID和组ID，使得新ID具有合适的特权或访问权限。与此类似，当程序需要降低其特权或组织对某些资源的访问时，也需要更换用户ID或组ID，新ID不具有相应特权或访问这些资源的能力。
在涉及与勇士，我们试图使用最小特权。setuid函数设置实际用户ID和有效用户ID，setgid函数设置实际组ID和有效组ID
更改用户的规则
1.若进程具有超级用户特权，则setuid函数将实际用户ID、有效用户ID以及保存的设置用户ID设置为uid；
2.若进程没有超级用户特权，但是uid等于实际用户ID或保存的设置用户ID，则setuid只将有效用户ID设置为uid。不更改实际用户和保存的设置用户ID。
3.若不满足上面两个条件，errno。
关于内核所维护的3个用户ID，需要注意一下几点：
1.只有超级用户可以更改实际用户ID；
2.晋档对程序文件设置了设置用户ID位时，exec函数才能设置为有效用户ID；
3.保存的设置用户ID是由exec复制有效用户ID而得到的。







getuid和geteuid只能获得实际用户ID和有效用户ID的当前值，并不能获得保存的设置用户ID的当前值。
1.函数setreuid和setregid
BSD支持setreuid函数，功能是交换实际用户ID和有效用户ID的值。
2.函数seteuid和setegid
POSIX包含了两个函数seteuid和setegid，由于更改有效用户ID和有效组ID。
一个非特权用户可以将其有效用户ID设置为其实际用户ID或其保存的设置用户ID。对于一个特权用户则可将有效用户ID的各个函数。











3.组ID
本章中所说明的一切都以类似方式适用于各个组ID。附属组ID不受setgid、setregid和setegid函数的影响。
解释器文件
此为文本文件，其起始行的形式是：
#! pathname[optional-argument]
在感叹号和pathname之间的开个是可选的，最常见的解释器文件以下列行开始：
#! /bin/sh
pathname通常是绝对路径名，对这种文件的识别是由内核作为exec系统调用处理的一部分来完成的。内核使调用exec函数的进程实际执行的并不是该解释器文件，问世在该解释器文件第一行中pathname所指定的文件。一定要解释器文件（文本文件，以#！开头）和解释器（pathname）中区分开来。
程序调用exec函数来指向一个解释器文件，解释器是可执行文件+参数：#!/usr/bin/awk  -f 
解释器文件的意义：
1.有些程序使用某种语言写的脚本，解释器文件可将这一事实隐藏起来；
2.解释器脚本在效率方面也提供了好处。shell脚本：首先读取命令，然后试图执行此文件，需要更多的开销。
3.解释器脚本使得我们可以使用除/bin/sh以外的其他shell来编写shell脚本。当execlp找到一个非机器可执行的可执行文件时，它总是调用/bin/sh来解释执行该文件。但是用解释器脚本则可简单写成#!/bin/csh。
函数system
在程序中执行一个命令字符串很方便，使用system函数则更容易做到这一点。因为system在实现中调用了fork、exec、waitpid，因此有3种返回值。
1.fork失败或waitpid返回出EINTR之外的出错，则system返回-1，并设置errno以指示类型。
2.如果exec失败，则其返回值如同shell执行了exit一样；
3.否则所有3函数都成功，那么system的返回值是shell的终止状态。
进程会计
启动该选项之后，每当进程结束时就写一个会计记录。典型的会计记录包含总量较小的二进制数据，一般包含命令名、所使用的CPU时间总量、用户ID和组ID、启动时间等。会计记录结构定义在文件acct.h中。
用户标识
任一进程都可以得到其实际用户ID和有效用户ID及组ID。系统通常记录用户登录时使用的名字，用getloin函数可以获取此登录名，找到运行程序的用户名。
如果调用此函数的进程没有连接到用户登录时所用的终端，则函数会失败。通常称这些进程为守护进程
进程调度
基于调度优先级的组粒度的控制。调度策略和调度优先级室友内核确定的。进程可以通过调整nice值选择以更低优先级运行。只有特权进程允许提高调度权限。进程通过nice函数获取或更改nice值，并不影响其他进程的nice值。
getpriority函数可以向nice函数那样用于获取进程的nice值，而且还能获取一组相关进程的nice值，如进程、进程组、用户ID。
setpriority函数可以为进程、进程组和属于特定用户的所有进程设置优先级。
进程时间
墙上时钟时间、用户CPU时间和系统CPU时间是时间度量。进程可以调用times函数来获得自己及子进程的时间度量值。times函数返回墙上时钟时间，此值为绝对值并非相对值。
第9章  进程关系
终端登录
由终端登录unix系统：基于字符的终端、仿真基于字符终端的图形终端、或者运行窗口系统的图形终端。
1.BSD终端登录
当系统自举时，内核创建进程ID为1的进程，也就是init进程。init进程使血糖进入多用户模式。init读取文件/etc/ttys，对每一个允许登录的终端设备，init调用一次fork，它所生成的子进程则exec getty程序。如下图所示。










上图中所有进程的时机用户ID和有效用户ID都是0（超级用户特权）。
getty对终端调用open函数，以读、写方式将终端打开。如果设备是调制解调器，则open可能会在设备驱动程序中滞留，直到用户拨号调制解调器，并且线路被接通。一旦设备被打开，则文件描述符0、1、2就被设置到该设备。然后getty输出“login：”之类的信息，并等待用户键入用户名。如果中断支持多种速度，则getty可以测试特殊字符一遍。当用户键入用户名后，getty的工作就完成了，然后调用logim程序：
execle(“/bin/login”, ”login”, ”-p”, username, (char *)0, envp);
init以一个空环境调用getty。getty以终端名和在gettytab中说明的环境说明字符串为login创建一个环境。
login能处理多想工作。因为它得到了用户名，所以能调用getpwnam取得相应用户的口令文件登录项。然后调用getpass以显示提示“password：”，接着读取用户键入的口令。它调用crypt将用户键入的口令加密，并与该用户在阴影口令文件中登录项的pw_passwd字段相比较。如果用户几次键入的口令都无效，则login以参数1调用exit表示登录是吧。父进程（init）链接到子进程的终止情况后，将再次调用fork，其后又执行getty，对此终端重复上述过程。
如果用户正确登录，login将完成一些工作。至此，登录用户的登录shell开始运行。其父进程ID是init进程（进程ID 1），所以当此登录shell终止时，init会得到通知，它会对该终端重复全部上述过程。登录shell的文件描述符0、1、2设置为终端设备














2.Mac OS X终端登录
与BSD终端登录进程的工作步骤基本相同，不同之处：
init的工作是有launchd完成的；
一开始提供的就是图形终端。
3.linux终端登录
非常类似于BSD，区别是说明终端配置的方式。
4.Solaris终端登录
支持两种终端登录：getty方式；ttymon登录。通常，getty用于控制台，ttymon则用于其他终端的登录。
网络登录
通过串行终端登录至系统和经由为了登录至系统两者之间的主要区别：网络登录时，在终端和计算机之间的连接不再是点到点的。
伪终端可以处理终端登录，也可以处理网络登录。她方针才行终端的运行学位，并将终端操作映射为网络操作。
1.BSD网络登录
inetd进程等待大多数的网络连接。init调用一个shell，shell脚本启动一个守护进程inetd。一旦此shell脚本终止，inetd的父进程就编程init。inetd等待TCPIP链接请求到达主机，而当一个链接请求到达时，就执行一次fork，然后生成子进程exec适当的程序。
重点是：当通过终端或网络登录时，我们得到一个登陆shell，其白早婚输入、标准输出和标准错误要么链接到一个终端设备，要么链接到一个为终端设备上。






2 Mac OS X网络登录：与BSD网络登录基本相同，只是守护进程从launchd运行的，
3.linux网络登录：与BSD网络登录基本相同，只是守护进程从xinetd运行的，更加精细，
4.Solaris网络登录：与BSD网络登录基本相同。
进程组
每个进程除了有一个进程ID之外，还属于提个进程组，进程组是一个或多个进程的集合。通常，它们是在一个作业中结合起来的，同一进程组的个进程接收来自同一终端的各种信号，每个进程有一个唯一的进程组ID。进程组ID类似于进程ID——它是一个正整数，并可存放在pid_t数据结构中。函数getgrp返回调用进程的进程组ID。SUS定义getpgid函数模仿此种运行行为。
每个进程组都有一个组长进程。组长进程的进程组ID等于其进程ID。进程组组长可以创建一个进程组、创建改组中的进程，然后终止。只要在某个进程组中一个进程存在，则该进程组就存在，这与其组长进程是否终止无关。从进程组创建开始到最后一个进程来看位置的时间区间成为该进程的生命期。某个进程组中的最后一个进程可以终止，也可以转移到另一个进程组。
进程调用setpgid可以加入一个现有进程组或创建一个进程组。
一个进程只能为它自己或它的子进程设置进程组ID。在它的子进程调用exec后，它就不能更改孩子进程的进程组。
会话
会话是有一个或多个进程组的集合。如下图所示。









形成以上会话的命令是：
proc1|proc2&proc3|proc4|proc5
进程调用setsid函数设置一个新会话，如果调用此函数的进程不是一个进程组的组长，则此函数创建一个新会话：
1.该进程变成新会话的会话首进程。此时，该进程是新会话中的唯一进程。
2.该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID。
3.该进程没有控制终端。如果在调用setsid之前该进程有一个控制终端，那么这种联系就被切断。
getsid函数返回会话首进程的进程组ID，同时也是会话ID。
控制进程
会话和进程组还有一些其他特性：
1.一个会话可以有一个控制终端。这通常是终端设备或伪终端设备。
2.建立与控制终端连接的会话首进程被称为控制进程。
3.一个会话中的几个进程组可被分为一个前台进程组以及一个或多个后台进程组。
4.如果一个会话有一个控制终端，则它有一个前台进程组，其他进程组为后台进程组。
5.无论何时键入终端的中断键，都将中断信号发送至前台进程组的所有进程。
6.无论何时键入终端的退出键，都将会退出信号发送至前台进程组的所有进程。
7.如果终端接口检测到调制调节器已经断开连接，则将挂断信号发送至控制进程。













函数tcgetpgrp、tcsetpgrp和tcgetsid
需要一种方法来通知内核哪一个进程组是前台进程组，终端设备驱动程序就能知道将终端输入和终端信号发送到何处。
tcgetpgrp函数返回前台进程组ID，它与在fd上打开的终端相关联。
如果进程有一个控制终端，则该进程可以调用tcsetpgrp将前台进程组ID设置为pgrpid。pgrpid值应该是在同一会话中的一个进程组的ID。fd必须引用该会话的控制终端。
大多数应用程序并不会直接调用者两个函数。他们通常由作业控制shell调用。
tcgetsid函数可以获得会话首进程的进程组ID。
需要管理控制终端的应用进程可以调用tcgetsid函数可以获得控制终端的会话首进程的进程组ID。
作业控制
作业控制允许在一个终端上启动多个作业（进程组），它控制哪一个作业可以访问该终端以及哪些作业在后台运行。作业控制要求以下3中形式的支持：
1.支持作业控制的shell。
2.内核中的终端驱动程序必须支持作业控制。
3.内核必须提供对某些作业控制信号的支持。
一个作业只是几个进程的集合，通常是一个进程管道。例如shell脚本如下所示：
pr *.c  | lpr &
make all &
在后台启动两个作业。当启动一个后台作业时，shell赋予它一个作业标识符，并调用一个或多个进程ID。
挂起键（Ctrl+Z），与终端驱动程序进行交互作业。键入此字使终端驱动程序程序将信号SIGTSTP发送至前台进程组中的所有进程，后台进程组作业则不受影响。实际上有3个特殊字符可使得终端驱动程序产生信号，并将它们发送至前台进程组：
1.终端字符（Delete或ctrl+c）产生SIGINT；
2.退出字符产生SIGQUIT；
3.挂起字符产生SIGTSTP。



























shell执行程序
ps命令可以检查shell执行程序的状态、进程组、控制终端、会话等，如果执行：
ps -o pid,ppid,pgid,sid,comm




ps的父进程是shell，shell和ps命令位于同一会话组和前台进程组（949）中。因为我们是用一个不支持作业控制的shell执行命令时得到该值的，所以称其为前台进程组。
ps -o pid,ppid,pgid,sid,comm  | cat1   |   cat2














孤儿进程组
一个父进程已终止的进程称为孤儿进程，这种进程有init进程收养。
注意的是，父进程终止时，子进程变成后台进程组，因为父进程是由shell作为前台作业执行的。后台进程组试图读控制终端时，会因出错而终止。
第10章  信号
信号概念
每个信号都有一个名字，如SIGALRM是闹钟信号。在头文件signal.h中，信号名都被调用为正整数常量。
很多条件产生信号：
1.当用户按某些终端键时，已发终端产生的信号。
2.硬件异常产生信号：除数为0、无效的内存引用等。
3.进程调用kill（2）函数可将任意信号发送给另一个进程或者进程组。
4.用户可用kill（1）命令将信号发送给其他进程。
5.当检测到某种软件条件已经发生，并应将其停止有关进程时也产生信号。
信号是异步事件的教练实例，信号随机产生。当某一信号出现时，告诉内核按下列3种方式之一进行处理：
1.忽略该信号。
2.捕捉该信号。
3.执行系统默认动作。
终止+core表示在进程当前目录工作的core文件中复制该进程的内核印象，使得系统使用core文件检查进程终止时的状态。
函数signal
信号机制最简单的接口是signal函数。在调用signal函数之后，指定了处理信号的函数地址。则在信号发生时，调用该函数，即为捕捉该信号，此函数为信号处理程序或信号捕捉程序。该函数要求一个整型参数（信号变量），而且无返回值。
1.程序启动
当执行一个程序时，所有信号的状态都是系统默认或忽略。通常所有信号都被设置为他们的默认动作，除非调用exec的进程忽略该信号。
2.进程创建
当一个进程调用fork时，其子进程集成父进程的信号处理方式。
不可靠的信号
早期代码：在信号发生之后到信号处理程序调用signal函数之间有一个时间窗口，在此段时间内，可能发生聊一次终端信号。第二个信号会造成默认动作，而对终端信号的默认动作是终止该进程。可能会发生信号丢失。
终端的系统调用
将系统覅有分为：低速系统调用和其他系统调用。低速系统调用是可能会使程序医院阻塞的一类系统调用。
用中断系统调用的方法来处理这种低速系统调用（IO操作）一个进程启动了读终端操作，而使用该终端设备的用户却离开该终端很长时间。
终端系统调用的自动重启动：ioctl、read、write、wait等。
可重入函数
进程捕捉到信号并对其几次你个处理时，进程正在执行的正常的指令序列就被信号处理程序临时终端，她首先执行该信号处理程序中的指令。如果从信号处理程序放回，则继续执行在捕捉到信号时进程正在执行的正常指令序列。但在信号处理程序中，不能判断捕捉到信号时进程执行到何处。
在信号处理称重保证调用安全的函数，这些函数是可重入的并称为异步信号安全。除了可重入以外，在信号处理操作期间，它会阻塞任何会引起不一致的信号发送。还有些函数是不可重入的：使用静态数据结构；调用malloc或free等操作；标准IO操作。
如果在信号处理程序中调用了一个不可重入的函数，则其结果是不可预知的。
SIGCLD语义
SIGCLD和SIGCHLD容易被混淆。对于SIGCLD的早起处理方式是：
1.如果进程明确地将SIGCLD信号的配置设置为SIG_IGN，则调用进程的子进程将不产生僵死进程。注意，这与默认动作“忽略”不同。子进程在终止时，将其转态丢弃。如果调用进程随后调用一个wait函数，那么它将阻塞直到所有子进程都终止，然后该wait会放回-1，并将其errno设置为ECHILD。
2.如果将SIGCLD的配置设置为不住，则内核立即检查是否有子进程准备好被等待。
可靠信号术语与语义
当造成信号的事件发生时，为进程产生一个信号。当一个信号产生时，内核通常在进程表中以某种形式设置一个标志。
当对信号采取了这种动作时，我们说向进程递送了一个信号。在信号产生和递送之间的时间间隔内，称信号是未决的。
进程可以选用“阻塞信号递送”。如果为进程产生了一个阻塞的信号，而且对该信号的动作是系统默认动作或捕捉该信号，则为该进程将此信号保持为未决状态，直到该进程对此信号解除了阻塞，或者对此信号的动作更改为忽略。内核在递送一个原来被阻塞的信号给进程时，才决定对它的处理方式。于是进程在信号递送给它之前仍可改变对该信号的动作。进程调用sigpending函数来判定哪些信号是设置为阻塞并处于未决状态的。
每个进程都有一个信号屏蔽字，它规定了当前要阻塞递送到该进程的信号集。对于每种可能的信号，该屏蔽字中都有一位与之对应。对于某种信号，若某对应位已被设置则它当前是被阻塞的。进程可以调用函数来检测和更改其当前信号屏蔽字。
信号编号可能超过一个整型所包含的二进制位。
函数kill和raise 
kill函数将信号发送给给进程或将承租，raise函数只允许进程向自身发送信号。
kill的pid参数有以下4中情况：
1.pid>0   将该信号发送给进程ID为pid的进程。
2.pid==0  将该信号发送给与发送进程属于同一进程组的所有进程，而且发送进程具有权限向这些进程发送信号。所有进程不包含系统进程集（内核进程和init）。
3.pid<0   将该信号发送给进程ID等于pid绝对值，而且发送进程具有权限向其发送信号的所有进程。所有进程不包含系统进程集（内核进程和init）。
4.pid==-1  将该信号发送给发送进程有权限向它们发送信号的所有进程。所有进程不包含系统进程集（内核进程和init）。
如前所属，进程将信号发送给其他进程需要权限。超级用户可将信号发送给任意进程。对于非超级用户，其基本规则是发送者的实际用户ID或有效用户ID必须等于接受者的实际用户ID或有效用户ID。
函数alarm和pause
使用alarm函数可以设置一个定时器，当定时器超时时，昌盛SIGALRM信号。如果不忽略或不捕捉此信号，则其默认动作是终止调用该alarm函数的进程。
每个进程只能有一个闹钟时间，如果调用alarm时，之前已为该进程注册的闹钟时间还没有超时，则该闹钟时间的余留值作为本次alarm函数调用的值返回。以前注册的闹钟时间则被新值代替。如果有以前注册的尚未超过的闹钟时间，而且本次调用的seconds的值为0，则取消以前的闹钟时间，其余留值仍作为alarm函数的返回值。
虽然SIGALRM的默认动作是终止进程，但是大多数使用闹钟的进程捕捉此信号。如果此时进程要终止，则在终止之前它可以执行所需的清理操作。如果我们向捕捉SIGALRM信号，则必须在调用alarm之前安装该信号的处理程序。如果我们先调用alarm，然后在我们能够安装SIGALRM处理程序之前已接到该信号，那么进程将终止。
paus函数使调用进程挂起直至捕捉到一个信号。只有执行一个信号处理程序并从其放回时，pause才返回。在这种情况下，pause返回-1，errno设置EINTR。
信号集
信号集可以表示多个信号。在sigprocmask类函数中使用这种数据类型，一遍告诉内核不允许发生该信号集中的信号。如前所属，不同的信号的编号可能超过一个整型量所包含的位数，所以一般而言，不能用整型量中的意味代表一种信号，也就是不能用一个整型量表示信号集。
数据类型sigset_t以包含一个信号集，并且定义5个处理信号集的函数。
函数sigemptyset初始化由set指向的信号集，清除其中所有信号。函数sigfillset初始化由set指向的信号集，使其包含所有信号。所有应用程序在使用信号集前，要对该信号集调用sigemptyset或sigfillset一次。
一旦已经初始化了一个信号集，以后就可在该信号集中增删特定的信号，函数sigaddset将一个信号添加到已有的信号集中，sigdelset则从信号集中删除一个信号。对所有以信号集作为参数的函数，总是以信号集地址作为向其传送的参数。
函数sigprocmask
一个进程的信号屏蔽字规定当前阻塞而不能递送给进程的信号集。调用函数sigprocmask可以检测或更改，或同时进行检测和更改进程的信号屏蔽字。
在调用sigprocmask后如果有任何未决、不再阻塞的信号，则在sigprocmask返回前，至少将其中之一递送给该进程。
函数sigpending
sigpending函数返回以信号集，对于调用进程而言，其中的各信号是阻塞不能递送的，因而也一定是当前未决的。该信号集通过set参数返回。
函数sigaction
sigaction函数的功能是检查或修改与指定与指定信号相关联的处理动作。
函数sigsetjmp和siglongjmp
函数sigsetjmp和siglongjmp可以在信号处理程序中进行非局部转移。这两个函数和setjmp、longjmp之间的唯一区别是sigsetjmp增加了一个参数。如果savemask非0，则sigsetjmp在env中保存进程的当前信号屏蔽字。调用siglongjmp时，如果带非0savemask的sigsetjmp研究保存了env，则siglongjmp从其中恢复保存的信号屏蔽字。
函数sigsuspend
更改进程的信号屏蔽字可以阻塞所选择的信号，或解除对它们的阻塞。但是可能丢失信号。
为了纠正这一问题，需要一个院子操作中先恢复信号屏蔽字，然后使进程休眠。这种功能是由sigsuspend函数所提供。进程的信号屏蔽字设置为由sigmask指向的值。在捕捉到一个信号或发生一个会终止该进程的信号之前，该进程被挂起。如果捕捉到一个信号而且从该信号处理程序返回，则sigsuspend函数返回，并且将该进程的信号屏蔽字设置为调用sigsuspend函数之前的值。
函数abort
abort函数的功能是使程序异常终止。此函数将SIGABRT信号发送给调用进程。
ISO C规定，调用abort将主机回家递送一个未成功终止的通知，其方法是调用raise函数。ISO C要求若捕捉到此信号而且相应信号处理程序返回，abort仍不会返回到其调用者。如果捕捉到此信号，则信号处理不能返回的唯一方法是调用exit等函数。
让进程捕捉SIGABRT信号的一条是，在进程终止之前有其执行所需的清理操作。
函数sleep、nanosleep、clock_nanosleep
sleep函数使调用进程被挂起直到满足下面两个条件之一：
1.已经过了所指定的墙上时钟时间；
2.调用进程捕捉到一个信号并从信号处理程序返回。
由于受到其他系统活动影响，实际返回时间比所要求的会迟一些。
nanosleep函数与sleep函数类似，但是提供纳秒级的角度。这个函数挂起调用进程，直到要求的时间已经超过或者某个信号中断该函数。
随着多个系统时钟的引入，需要使用相对于特定时钟的延迟时间来挂起调用线程。clock_nanosleep函数可以提供这个功能。
函数sigqueue
通常一个信号带有一个位信息：信号本身。除了对信号排队以外，这些扩展允许应用程序在递交信息时传递更多的信息。这些信息嵌入在siginfo结构中，除了系统提供的信息，应用程序还可以向信号处理程序传递整数或指向包含更多信息的缓存区指针。
使用排队信号必须做以下几个操作：
1.使用sigaction函数安装信号处理程序时指定SA_SIGINFO标志。如果没有给出这个标志，信号会延迟，但信号是否进入队列要取决于具体实现。
2.在sigaction结构的sa_sigaction成员中提供信号处理程序。实际可能也许用户使用sa_handler字段，但不能获取sigqueue函数发送出来的额外信息。
3.使用sigqueue函数发送信号。
sigqueue函数只能把信号发送给单个进程。信号不能被诬陷排队。
作业控制信号
POSIX.1有以下6个作业控制信号：
SIGCHLD		子进程停止或终止
SIGCONT		如果进程已停止，则使其继续运行
SIGSTOP		停止信号
SIGTSTP		交互式停止信号
SIGTTIN		后台进程组成员度控制终端
SIGTTOU		后台进程组成员控制终端
信号名和编号
信号编号和信号名之间的映射，可以使用psignal函数可抑制地打印与信号编号对应的字符串。
如果在sigaction信号处理程序中有siginfo结构，可以使用psiginfo函数打印信号信息。
如果只需要信号的字符描述部分，也不需要把它写到标准错误文件中，可以使用strsignal函数，它类似于strerror。
第11章  线程
线程概念
典型的unix进程可以看成只有一个控制线程。有了多个控制线程以后，在程序设计时就可以把进程涉及成在某一时刻能够做不止一件事，每个线程处理各自独立的任务。这种方法有很多好处。
1.通过为每种事件类型分配单独的处理线程，可以简化处理异步事件代码。每个线程在就行事件处理时可以采用同步编程模式，异步编程模式比异步编程模式简单很多；
2.多个进程必须使用操作系统提供的复杂机制才能实现内存和文件描述符的共享，而多个线程自动地可以访问系统的存储导致和文件描述符。
3.有些问题可以分解，从而提高程序的吞吐量。
4.交互的程序同样可以通过使用多线程来改善相应时间，多线程可以把程序中处理用户输入输出的部分与其他部分分开。
即便多线程程序在单核处理器上，也能得到多线程编程模型的好处。处理器的数量并不影响程序结构，所以不管处理器的个数多少，程序都可以通过使用线程得以简化。而且多线程程序在串行化任务时不得不阻塞，其他线程可以运行。
每个线程都包含有表示执行环境所需的信息，其中包括进程中标识线程的线程ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、errno变量以及线程私有数据。一个进程的所有信息对该进程的所有线程都是共享的，包括可执行程序的代码、程序的全局内存和对内存、栈以及文件描述符。
线程标识
每个线程都有一个线程ID，线程ID只有在它所属的进程上下文中才有意义。
线程ID是用pthread_t数据类型来表示的实现的时候可以用一个结构来代表pthread_t数据类型。使用pthread_equal函数来对比两个线程ID。用结构标识pthread_t数据类型的后果是不能用一种可一直的方式打印该数据类型的值。
线程可以通过调用pthread_self函数获得自身的线程ID。
当线程需要识别以此线程ID作为标识的数据结构时，pthread_self函数可以与pthread_equal函数一起使用。列入，主线程可能把工作任务放在一个队列中，用线程ID来控制每个工作线程处理那些作业。
线程创建
新增的线程可以通过调用pthread_create函数创建。当pthread_create函数成功返回时，新创建线程的线程ID会被设置成线程所指向的内存单元。
线程创建时并不能保证那个线程会先运行：是新创建的线程，还是调用线程。新创建的线程可以访问进程的地址空间，并且进程号调用线程的浮点环境和信号屏蔽字，但是该线程的挂起信号集会被清除。
线程终止
如果进程中的任意线程调用了exit、_Exit、_exit，那么整个进程就会终止。与此相类似，如果默认的动作是终止进程，那么，发送到线程的信号就会终止整个进程。
单个线程可以通过3中方式退出，因此可以在不终止整个进程的情况下，停止它的控制流：
1.线程可以简单地从启动例程中返回，返回值是线程的退出码；
2.线程可以被统一进程中的其他进程取消；
3.线程调用pthread_exit函数（并不是exit、_Exit、_exit函数）。
pthread_exit函数的参数是一个无类型指针，与传给启动例程的单个参数类似。进程中其他线程也可以通过调用pthread_join函数访问到这个指针。调用pthread_exit函数的线程将一直阻塞，直到指定的线程调用pthread_exit函数、从启动例程中返回或者被取消。
pthread_join函数自动把线程至于分离状态，这样资源就可以恢复。
当一个线程通过pthread_exit函数推出或者简单地从启动例程中返回时，进程中的其他线程可以通过调用pthread_join函数获得该线程的退出状态。
pthread_cancel函数可以请求取消同一进程的其他线程。默认情况下，pthread_cancel函数会由参数标识的线程的行为表现为如图调用参数为CLANCELED的pthread_exit函数，但是，线程可以选择忽略取消或者控制如何被取消。
线程可以安排它退出时需要调用的函数，这样的函数称为线程清除程序。一个线程可以建立多个清除处理程序。处理程序记录在栈中，他们的执行顺序与注册时相反。
线程同步
当多个控制线程共享相同的内存时，线程间需要检测同步，确保他们在访问变量的存储内容时不会访问到无效的值。
为了解决不一致问题，线程不得不使用锁，同一时间只允许一个线程访问该变量。
互斥量
可以使用线程的互斥接口来保护数据，确保同一时间内只有一个线程访问数据。互斥量从本质上就是一把锁，在访问共享资源钱对互斥量进行加锁，在访问完成后解锁互斥量。在互斥量进行加锁之后，任何其他试图再次对胡吃两加锁的线程都会被阻塞知道当前线程释放该互斥锁。
互斥变量是用pthread_mutex_t数据类型表示的。在使用互斥变量以前，必须首先对它进行初始化，可以把它设置为常量，也可以调用pthread_mutex_init函数进行初始化。如果动态分配互斥量，在释放先需要调用pthread_mutex_destroy。要用默认的属性初始化互斥量。
对互斥量进行加锁，需要调用pthread_mutex_lock。如果互斥量已经上锁，调用线程将阻塞知道释放量被释放。对互斥量解锁，需要调用pthread_mutex_unlock。
如果线程不希望被阻塞，可以使用pthread_mutex_trylock尝试对互斥量进行加锁。如果调用pthread_mutex_trylock时互斥量处于未锁住状态，那么pthread_mutex_trylock将锁住互斥量，不会出现阻塞直接返回0，否则pthread_mutex_trylock就会失败，不能锁住互斥量。
避免死锁
如果线程视同对同一互斥量加锁两次，那么它自身就会陷入死锁状态，但是使用互斥量时，还有其他不太明显的方式也能产生死锁。
1.可以通过仔细控制互斥量的顺序来避免死锁的发生。但是应用程序的结构使得对互斥量进行排序很困难。
2.当占有不了所有的互斥量时，先释放占有额所，然后过一段时间再重新尝试。
函数pthread_mutex_timelock
当线程试图获取一个已加锁的互斥量时，pthread_mutex_timelock互斥量源于允许绑定线程阻塞时间。pthread_mutex_timelock与pthread_mutex_lock函数基本等价，但是达到超时时间时，pthread_mutex_timelock不会对互斥量进行加锁，而是返回错误码。超时指定愿意等待的绝对时间。这个超时时间使用timespec结构表示的。
这个函数在实际情况下，也会导致死锁。
读写锁
读写锁与互斥量类似，不过读写锁允许更高的并行性。互斥量要么是锁住状态，要么就是不加锁，而且一次只有一个线程可以对其加锁。读写锁可以有3中状态：读模式下加锁状态，写模式下加锁状态，不加锁状态。一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式下的读写锁。
当读写锁是写加锁状态时，在这个所被解锁之前，所有试题对这个所加锁的线程都会被阻塞。在读写锁在读加锁状态时，所有试图以读模式对它进行加锁的线程都可以得到访问权，但是任何希望以写模式对次所进行加锁的线程都会阻塞，直到所有的线程释放他们的读锁为止。
读写锁非常适合于对数据结构读的次数大于写的情况。
读写锁页脚共享互斥锁。当读写锁是读模式锁住时，就可以说成是以共享模式锁住的。当它是写模式锁住的时候，就可以说是以互斥模式锁住的。
与互斥量相比，读写锁在使用前必须初始化，在释放他们底层的内存之前必须销毁。
读写锁通过调用pthread_rwlock_init进行初始化。
在释放读写锁占用的内存之前，需要调用pthread_rwlock_destory做清理工作。如果pthread_rwlock_init为读写锁分配资源，pthread_rwlock_destory将释放这些资源。如果调用pthread_rwlock_destory之前就释放了读写锁占用的内存空间，那么分配给这个锁的资源就会丢失。
在读模式下锁定读写锁，需要调用pthread_rwlock_rdlock。要在写模式下锁定读写锁，需要调用pthread_rwlock_wrlock。不管以何种方式锁住读写多，都可以调用pthread_rwlock_unlock进行解锁。
带有超时的读写锁
pthread_rwlock_timerdlock和pthread_rwlock_timewrlock可以是应用程序在获取读写锁时陷入永久阻塞状态。
条件变量
条件变量是线程可用的另一种同步机制。条件变量给多个线程提供一个回合的处所。条件变量与互斥量一起使用时，允许线程以无竞争的方式等待特定的条件发生。
条件本身是由互斥量保护的。线程在改变条件状态之前必须首先锁住互斥量。其他线程在获得互斥量之前不会察觉到这种改变，因为互斥量必须在锁定以后才能计算条件。
在使用条件变量之前，必须先进行初始化。由pthread_cond_t数据类型表示的条件变量可以用两种方式进行初始化。可以把常量直接付给静态分配的条件变量，但是如果条件变量是动态分配的，则需要使用pthread_cond_init函数对它进行初始化。
在释放条件变量底层的内存空间之前，可以使用pthread_cond_destory函数对条件变量进行反初始化。
我们使用pthread_cond_wait等待条件变量变为真。如果在给定的时间内条件不能满足，那么会生成一个返回错误码的变量。
传递给pthread_cond_wait的互斥量对条件进行保护。调用者把锁住的互斥量传给函数，函数然后自动把调用线程放在等待条件的线程列表上，对互斥量解锁。这就关闭了条件检查和线程进入休眠状态等待条件改变这两个操作之间的时间通道，这样线程就不会错过条件的任何变化。pthread_cond_wait返回时，互斥量再次被锁住。
自旋锁
自旋锁与互斥量类似，但它不是通过休眠使进程阻塞，而是在获取锁之前一直处于忙活等阻塞状态。自旋锁可用以下情况：所被持有的时间段，而且线程并不希望在重新调度上花费太多时间。
自旋锁通常作为底层原语用于实现其他类型的锁。根据他们所基于的系统体系结构，可以通过使用测试并设置指令有效地实现。当自旋锁用在非抢占式内核中时是非常有用的：除了通过互斥锁机制以外，他们会阻塞中断，这样中断处理程序就不会让系统陷入死锁状态。因为她需要获取已被加锁的自旋锁。
在用户层，自旋锁并不是很常用，除非运行在不允许抢占的实时调度类中。
用pthread_spin_init函数对自旋锁进行初始化，用pthread_spin_destory函数进行自旋锁的反初始化。
屏障
屏障是用户协调多个线程并行工作的同步机制。屏障允许每个线程等待，知道所有的合作线程都到达某一点，然后从该店继续执行。pthread_join函数就是一种屏障，允许一个线程等待，直到另一个线程退出。但是屏障对象的概念更广，他们允许任意数量的线程等待，知道所有线程完成处理工作，而线程不需要退出。所有线程达到屏障后可以接着工作。
可以使用pthread_barrier_init函数对屏障进行初始化，用pthread_barrier_destroy函数反初始化。
调用pthread_barrier_wait函数来表明，线程已完成工作，准备等所有其他线程赶上来。调用此函数的线程在屏蔽计数未满足条件时，会进入休眠状态。如果该线程是最后一个调用pthread_barrier_wait函数的线程，就满足了屏障计数，所有的线程都被唤醒。
一旦达到屏障计数值，而且线程处于非阻塞状态，屏障就可以被重用。但是除非在调用了pthread_barrier_destroy函数之后，又调用了pthread_barrier_init函数对屏障进行初始化，否则屏障计数不会改变。
第12章  线程控制
线程限制
通过sysconf函数进行查询线程的限制：







线程属性
pthread接口允许我们通过设置每个对象关联的不同属性来细调线程和同步对象的行为。通常，管理这些属性的函数都遵循细调的模式：
1.每个对象与它自己类型的属性对象进行关联；
2.有一个初始化函数，把属性设置为默认值；
3.还有一个销毁属性对象的函数，如果初始化函数分配了与属性对象关联的资源，销毁函数负责释放这些资源；
4.每个属性都有一个从属性对象中获取属性值函数；
5.每个属性都有一个设置属性值的函数。
使用pthread_attr_t结构修改线程默认属性，并把这些属性与创建的线程联系起来。可以使用pthread_attr_init函数初始化pthread_attr_t结构。可以使用pthread_attr_destory函数反初始化pthread_attr_t结构。
如果对现有某个进程的终止状态不感兴趣的话，可以使用pthread_detach函数让操作系统在线程退出时收回它所占用的资源。如果在创建线程就知道不需要了解线程的退出状态，就可以修改pthread_attr_t结构的detachstate线程属性，让线程一开始就处于分离状态。pthread_attr_setdetachstate函数用于设置。pthread_attr_getdetachstate函数用于获取。
SUS支持线程属性，并使用pthread_attr_setstack和pthread_attr_getstack函数对线程属性进行管理。pthread_attr_setstacksize和pthread_attr_getstacksize函数可以读取或设置线程属性。
同步属性
就像线程具有属性一样，线程的同步对象也有属性。自旋锁的一个属性成为进程共享属性。
互斥量属性
互斥量属性用pthread_mutexattr_t表示。调用pthread_mutexattr_init函数进行初始化。如果动态分配互斥量，在释放先需要调用pthread_mutexattr_destroy。要用默认的属性初始化互斥量。
pthread_mutexattr_init函数将用默认的互斥量属性初始化pthread_mutexattr_t结构。3个属性：进程共享属性、健壮属性以及类型属性。
在进程中，多个线程可以访问同一个同步对象，此时进程共享互斥量属性设置为PTHREAD_PROCESS_PRIVATE。
pthread_mutexattr_getpshared和pthread_mutexattr_setpshared函数获取和设置进程共享属性。
互斥量健壮属性与在多个进程间共享的互斥量有关。当持有互斥量的进程终止时，需要解决互斥量状态恢复的问题。互斥量处于锁定状态，恢复起来很困难。其他阻塞在这个所的进程将会一直阻塞下去。
pthread_mutexattr_setrobust和pthread_mutexattr_getrobust函数设置和获取健壮的互斥量属性的值。
pthread_mutex_consistent函数可以指明与该互斥量相关状态在互斥量解锁之前一致。
类型互斥量属性克制着互斥量的锁定特性。pthread_mutexattr_settype和pthread_mutexattr_gettype函数获取和设置互斥量类型属性。
读写锁属性
读写锁的属性可以使用pthread_rwlockattr_init和pthread_rwlockattr_destory初始化和反初始化pthread_rwlockattr_t结构。
读写锁的唯一属性是进程共享属性，它与互斥量的进程共享属性相同。pthread_rwlockattr_setpshared和pthread_rwlockattr_getpshared来读取和设置线程共享属性。
条件变量属性
SUS目前定义了条件变量的两个属性：进程共享属性和时钟属性。
pthread_condattr_init和pthread_condattr_destory初始化和反初始化pthread_condattr_t结构。
使用pthread_condattr_setpshared和pthread_condattr_getpshared来读取和设置线程共享属性。
时钟属性克制计算pthread_cond_timedwait函数的超时参数时采用的是那种时钟，使用pthread_condattr_setclock和pthread_condattr_getclock来读取和设置线程的时钟属性
屏障属性
屏障也有属性，pthread_barrierattr_init和pthread_barrierattr_destory初始化和反初始化屏障属性。
目前定义的捧在手心只有进程共享属性，它控制着屏障是可以被多进程的线程使用，还是只能被初始化屏障的进程内的多线程使用。pthread_barrierattr_setpshared和pthread_barrierattr_getpshared函数可以获取或设置进程共享属性。
重入
POSIX中一些非线程安全函数，系统会通过课题太的线程安全版本。通过修改接口，要求调用者自己提供缓冲区可以是函数变为线程安全。线程安全函数是可重入函数。
如果一个函数对多个线程来说是可重入的，就说这个函数就是线程安全的。但这并不能说明对信号处理程序来说该函数也是可重入的。如果函数读异步信号处理程序的重入是安全的，那么就可以说函数是异步信号安全的。
线程特定数据
线程特定数据，也成为线程私有数据，是存储和查询某个特定线程相关数据一种机制，是形成单独的数据副本：
1.需要维护基于每线程的数据；
2.基于线程的接口适应多线程环境的机制。
一个进程中所有线程都可以访问这个进程的整个地址空间，除了使用寄存器以外，一个线程没有办法阻止另一个线程访问它的数据，线程特定数据也不例外。虽然底层的实现部分并没有阻止这种访问能力，但是管理线程特定数据的函数可以提高线程间的数据独立性，使得线程不太容易访问到其他线程的线程特定数据。
在分配线程特定数据之前，需要创建于该数据关联的键。这个键将用于获取对线程特定数据的访问。使用pthread_key_create创建一个键。
对于所有线程，可以通过调用pthread_key_delete来取消键与线程特定数据值之间的关联。
在初始化阶段可能发生竞争，从而导致多次调用pthread_key_create函数。为了解决这种竞争调用pthread_once函数。每个线程都调用pthread_once函数时，系统能够保证初始化例程只被调用一次。
键一旦创建之后，通过pthread_setspecific函数把键和线程特定数据关联起来，也可以通过pthread_getspecific函数获得线程特定数据的地址。
取消选项
有两个线程属性并没有包含在pthread_attr_t结构中，他们是可取消状态和可取消类型。这两个属性影响着线程在响应pthread_cancel函数调用时所呈现的行为。
可取消状态可以通过pthread_setcancelstate函数修改。
pthread_cancel函数调用并不等待线程终止。默认情况下，线程取消请求发出以后还是继续运行，知道线程到达某个取消点。取消点是线程检查它是否被取消的一个位置，如果取消了，则按照请求行事。可以通过pthread_testcancel函数来添加自己的取消点。
我们所描述的默认取消类型也称为推迟取消。调用pthread_cancel函数以后，在线程到达取消点之前，并不会出现真正的取消。
调用pthread_testcanceltype函数来修改取消类型。
异步取消与推迟取消不同，因为异步取消可以在任意时间撤销，而不是非得等到取消点才能被取消。
线程和信号
即使是在基于线程的编程范型中，信号处理有时候也是很复杂的。把线程引入编程范型，就使得信号的处理变得更加复杂。
每个线程都有自己的信号屏蔽字。但是信号的处理是进程中所有线程共享的。这意味着单个线程可以阻止某些信号，但当某个线程修改了某个给定信号相关的处理行为之后，多有的线程都必须共享这个处理行为的改变。
进程的信号是递送到单个线程的。如果一个信号与硬件故障相关，那么该信号一般会被发送到引起该事件的线程中去，而其他的信号则被发送到任意一个线程。
pthread_sigmask函数用来阻止信号的发送；
sigwait函数用来等待一个或多个信号出现；
pthread_kill函数用来将信号发送给线程。
线程和fork
当线程调用fork时，就位子进程创建整个进程地址空间的副本。
子进程通过集成整个地址空间的副本，还从父进程那儿继承了每个互斥量、读写锁和条件变量的状态。如果父进程包含一个以上的线程，子进程在fork返回以后，如果紧接着不是钓鱼exec的话，就需要清理锁状态。
在子进程内部，只存在一个线程，它是由父进程中调用fork的线程的副本构成的。如果父进程中的线程占有锁，子进程将同样占有这些锁。问题是子进程并不包含占有锁的线程的副本，所以存在不一致等问题。为了解决这一问题，调用pthread_atfork函数建立fork处理程序，最多可以安装3个帮助清理锁的函数。
虽然pthread_atfork函数可以使得fork之后的所状态保持一致，但它还有一些问题：
1.没有很好的部分对较为复杂的同步对象进行状态的程序初始化；
2.某些错误检查的互斥量实现在child fork处理程序试图对父进程加锁的互斥量进行解锁时会尝试错误。
3.递归互斥量不能在child fork处理程序中清理。
4.如果子进程只允许调用异步信号安全的函数，child fork处理程序就不能清理同步对象，因为用于操作清理的所有函数不是异步信号安全的。
5.如果要用程序在信号处理程序中调用了fork，child fork处理程序只能调用异步安全的函数。
线程和IO
pread和pwrite函数可以对共享的文件描述符进行操作。
第13章  守护进程
守护进程是生存期长的一种进程。在系统引导装入时启动，尽在系统关闭时才终止。因为没有控制终端，所以在后台运行。
守护进程的特征
系统进程依赖于操作系统实现。父进程ID为0的各进程通常是内核进程，它们作为系统引导装入过程的一部分而启动。内核进程是特殊的，通常存在于系统的整个生命期中你那个。它们以超级用户特权运行，无控制终端，无命令行。
在ps的输出实例中，内核守护进程的名字出现在方括号中，如下图所示。如linux使用一个名为kthreadd的特殊内核进程来创建其他内核进程，所以为其他内核进程的父进程。对于需要在进程上下文执行工作但却不被用户层进程上下文调用的每一个内核组件，通常有一个它自己的内核守护进程。如linux中：
1.kswapd守护进程也陈伟内核换页守护进程。它支持虚拟内存子系统在一段时间后将脏页面慢慢地协会磁盘来回收这些页面。
2.flush守护进程在可用内存达到设置的最小阈值时将脏页面冲洗至磁盘。
3.sync_supers守护进程定期将文件系统元数据冲洗至磁盘。
4.jbd守护进程帮助实现ext4文件系统的日志功能。





rpcbind守护进程提供将远程过程调用（RPC）程序号映射为网络端口号的服务。rsyslogd守护进程可以被由管理员启用的将系统消息记入日志的任何程序使用。
inetd守护进程监听系统网络接口，以便来自网络的对各种网络服务进程的请求。
cron守护进程在定期安排的日期和时间执行命令。
大多数的守护进程都以超级用户特权运行。所有守护进程都没有控制终端。内核守护进程以无控制终端方式启动。用户层守护进程缺少控制终端可能是守护进程调用了setsid的结果，并且用户层守护进程的父进程是init进程。
编程规则
在编写守护进程程序时需要遵守一些基本规则。按照以下规则编写函数daemonize：
1.首先要做的是umask将文件模式创建屏蔽字设置为一个已知数。
2.调用fork，然后父进程exit
3.调用setsid创建一个新会话：成为新回话的首进程；成为新进程组的组长进程；没有控制终端。
4.将当前工作目录更改为根目录或者某个指定位置。
5.关闭不需要的文件描述符。
6.某些守护进程打开/dev/null使其具有文件描述符0、1、2。
出错记录
守护进程存在的一个问题就是如何处理出错消息。BSD的syslog得到了广泛的应用。










有3种产生日志消息的方法：
1.内核例程可以调用log函数。
2.大多数用户进程（守护进程）调用syslog函数来产生日志消息。
3.无论一个用户进程是在此主机上，还是在通过TCPIP网络连接到此主机的其他主机上，都可将日志消息发现UDP端口514。
syslogd守护进程有一个配置文件syslog.conf，接口是syslog函数。openlog和closelog是可选择的，用于打开和关闭文件描述符。
setlogmask函数用于设置进程的记录优先级屏蔽字。
单实例守护进程
为了正常运作，某些守护进程会实现为，在任意时刻只运行该守护进程的一个副本。文件和记录锁机制为一个守护进程只有一个副本运行提供了基础。文件锁和记录锁提供了一种方便的互斥机制。如果守护进程在一个文件的整体上得到了一把写锁，那么在该守护进程终止时，这把锁将被自动删除。
守护进程的惯例
在unix系统中，守护进程遵循下列同一惯例：
1.若守护进程使用锁文件，那么该文件通常存储在/var/run目录中。
2.若守护进程支持配置选项，那么配置文件通常存在/etc目录中。
3.守护进程可用目录项启动，但通常他们是由系统初始化脚本之一启动的。
4.若一个守护进程有一个配置文件，那么当该守护进程启动时会读该文件，但在此之后一般就不会再查看他。
客户进程-服务器进程模型
守护进程常常用作服务器进程。一般而言，服务器进程等待客户进程与其联系，提出某种类型的服务要求。服务器与客户端之间的通信有单向的，也有双向通信。双向通信：客户进程向服务器进程发送请求，服务器进程则向客户进程回答应答。

第14章  高级IO同步属性
非阻塞IO
低速系统调用时可能会使进程永远阻塞的一类系统调用：
1.如果某些文件类型的数据并不存在，读操作可能会使调用者永远阻塞。
2.如果数据不能被相同的文件类型立即接受，写操作可能会使调用者永远阻塞。
3.在某种条件发生之前打开某些文件类型可能会发生阻塞；
4.对研究加上强制锁的文件进行读写；
5.某些ioctl操作；
6.某些进程间通信。
非阻塞IO使我们可以发出open、read和write这样的IO操作，并使这些操作不会永远阻塞。如果这种操作不能完成，则调用立即出错返回，表示操作如继续执行将阻塞。
对于一个给定的描述符，有两种为其指定非阻塞IO的方法：
1.如果调用open获得描述符，则可指定O_NONBLOCK标志；
2.对于已经打开的一个描述符，则可调用fcntl，由该函数打开O_NONBLOCK标志。
可以将应用进程设计成使用多线程的，从而避免使用非阻塞IO。如若我们能在其他线程中继续进行，则可以允许单个线程在IO调用中阻塞。
记录锁
记录锁的功能是：当一个进程正在读取或修改文件的某个部分时，使用级卢梭可以组织其他进程修改同一文件内。术语是字节范围锁，锁定的只是文件内的一个区域。
1.fcntl记录锁
int  fcntl(int fd,int cmd,……/* struct flock *flockptr */);
对于记录锁，cmd是F_GETLK、F_SETLK或F_SETLKW。第三个参数指向flock结构的指针。符flock结构的说明如下：
1.所希望的锁类型：共享读锁、独占性写锁或解锁一个区域；
2.要加锁或解锁区域的起始字节偏移量；
3.区域的字节长度；
4.进程ID持有的锁能阻塞当前进程。
共享读锁和独占性写锁基本规则：任意多个进程在一个给定的字节上都可以有一把共享的读锁，但是在一个给定的字节上只能有一个进程有一把独占写锁。但是这种兼容性规则只适用于不同进程提出的所要求，并不适用于单个进程提出的多个锁要求：如果一个进程对一个文件区域已经有一把锁，那么新锁将替换已有锁。加读锁时，该描述符必须是读打开。加写锁时，该描述符必须是写打开。
下面说明一下fctnl函数的3种命令：
F_GETLK		判断由flockptr所描述的锁是否会被另外一把锁所排斥。
F_SETLK		设置由flockptr所描述的锁。此命令也用来清除锁定的锁。
F_SETLKW	这个命令是F_SETLK的阻塞版本。
这种记录锁也有发生死锁的可能性。检测到死锁时，内核必须选择一个进程接收出错返回。

2.锁的隐含继承和释放
记录锁的自动继承和释放有3条规则：
1.锁与进程和文件两者相关联。
2.由fork产生的子进程不继承父进程所设置的锁。
3.执行exec后，新程序可以继承原执行程序的锁。

3.FreeBSD实现
记录锁的自动继承和释放的第一条规则：锁与进程和文件两者相关联。
考虑一个进程，它执行下列语句
fd1=open(……);
write_lock(fd1,0,SEEK_SET,1);
if ( (pid = fork() ) > 0){
	fd2=dup(fd1);
	fd3=open(…..);
}
else if (pid ==0)
read_lock(fd1, 1, SEEK_SET, 1);
pause();
下图显示了父进程与子进程暂停（执行pause（））后的数据结构情况





















4.在文件尾端加锁
在对相对于文件尾端的字节范围加锁或解锁时需要特别小心。该写锁从当前文件尾端起，包括以后可能追加写到该文件的任何数据。
write_lock(fd, 0, SEEKEND, 0);
write(fd, buf, 1);
un_lock(fd,0, SEEKEND);
write(fd, buf, 1);
这个代码简单明了，首先加锁，然后解锁，最后追加。但是造成以下错误






当前偏移量和文件尾端可能会不断变化，而这种变化又不应影响现有锁的状态，所以内核必须独立于当前文件偏移量或文件尾端而记住锁。
4.建设性锁和强制性锁
如果数据库中都是用一致的方法来处理记录锁，则称这些进程为合作进程。若这些函数为唯一地用来访问数据库的函数，那么它们使用建设性锁是可行的，这些进程也被称为非合作进程。
强制性锁会让内核检查每一个open、read、和write，验证调用进程是否违背了正在访问的文件上的某一把锁。
IO多路转接
当从一个描述符读取，然后写到来一个描述符，可以使用阻塞IO。同时可以使用父子进程来解决这个问题，但是信号的传递使得程序更加复杂。也可以使用一个进程的两个线程，但是线程的同步的复杂度不可避免。另一个办法是使用循环非阻塞IO，但是轮训浪费CPU时间。还有一个技术称为异步IO，利用这种技术，进程告诉内核：当描述符准备好可以今次那个IO时，用一个信号通知它，但是只能在描述符引用终端设备或网络时才能起作用，还有一个问题就是信号会存在冲突。
一种比较好的技术是使用IO多路转接。
函数select和pselect
传给select的参数告诉内核：描述符，设置条件，等待时间。
从select返回，内核告诉我们：已准备的描述符，准备读、写、异常消息。
POSIX.1也定义了select的辩题，称为pselect。Pselect余select系统。
函数poll
Poll函数类似于select，但是程序员接口有所不同。poll函数可用于任何类型的文件描述符。
异步IO
异步IO使用一个信号通知新城，对某个描述符锁关心的某件事情已经发生。在使用异步IO的时候，要通过选择来灵活处理多个并发操作，这会使得应用程序的设计复杂化。更简单的做法可能是使用多线程，使用同步模式来编写程序，并让这些线程以异步的方式运行。
函数readv和writev
readv和writev函数用于在一次函数调用中读写多个非连续的缓冲区。有事也将这两个函数称为散布读和聚集写。
writev函数从缓冲区中聚集输出数据的顺序是0、1、2、...、IOVMAX-1。writev函数返回输出的字节总数，通常应的部分同意所有缓冲区长度之和。
readv函数降读入的数据按上述顺序散布到缓冲区中。readv首先填充一个缓冲区，在填充下一个。readv返回读到的字节总数。如果遇到文件微端，已无数据可读，则返回0。
函数readn和writen
管道、fifo一级某些设备具有以下两种性质：
一次read操作锁返回的数据可能少于锁要求的数据；
一次write操作的返回值也可能少于指定输出的字节数。
通常，在读写一个通道、网络设备或终端时，函数readn和writen的功能分别是读写指定的N字节数据，兵处理返回值可能小于要求值的情况。这两个函数只是安许多次调用read和write直至读、写了N字节数据。
存储映射IO
存储映射IO能将一个磁盘文件映射到存储空间的一个缓冲区上，于是，当从缓冲区中取数据时，就相当于读文件的相应字节。当数据存入缓冲区时，相应字节就自动写入文件。
Mmap函数可以将一个给定的文件映射到一个存储区域。
调用mprotect函数可以更改一个现有映射的权限。
如果共享映射中的页面被修改，那么可以调用msync将该页面冲洗到被映射的文件中。
当进程终止时，会自动解除存储映射区的映射，或直接调用Munmap函数也可以解除映射区。
第15章  进程间通信
管道
管道是最古老通信机制，局限：
历史上是半双工；
只能在公共祖先的两个进程间使用。
FIFO没有第二种局限性，unix域套接字没有这两种局限性。
管道是通过调用pipe函数创建的。fstat函数对管道的每一端都返回一个FIFO类型的文件描述符。









单个进程中的管道几乎没有任何用处。通常，进程会先调用pipe，接着调用fork，从而创建从父进程到子进程的IPC通道，反之依然。如下图所示。









fork之后，对于父进程到子进程的管道，父进程关闭管道的读端，子进程关闭写端。如下图所示。








函数popen和pclose
常见的操作时创建一个链接到另一个进程的管道，标准IO库提供了两个函数popen和pclose。这两个函数实现的操作是：创建一个俄管道，fork一个子进程，关闭未使用的管道端口，执行一个shell运行忙碌，然后等待命令终止。
popen先执行fork，然后调用exec执行cmdstring，并且放回一个标准IO文件指针。
pclose函数关闭标准IO流，等待命令终止，然后返回shell的终止状态。
协同进程
unix系统过滤程序从标准输入读取数据，向标准输出写数据。几个过滤程序通常在shell管道中线性链接。当一个过滤程序即产生某个过滤程序的输入，又读取该过滤程序的输出时，变成协同进程。协同进程通常在shell的后台运行，其标准输入和标准输出通常连接到另一个程序。







FIFO
FIFO是命名管道。为命名的管道只能在两个相关的进程之间使用，而且这两个相关的进程还有一个共同的祖先进程，但是通过FIFO，不想管的进程也能交换数据
创建FIFO类似于创建文件。
mkfifo函数用于创建FIFO。
mkfifoat函数与mkfifo函数相似。
一个给定的FIFO有多个写进程是常见的。如果不希望多个进程缩写的数据交叉，则必须考虑原子写操作。FIFO有以下两种用途：
shell命令使用FIFO将数据从一个管道传送到另一条时，无需创建中间临时文件。
客户进程-服务器进程应用程序中，FIFO作为汇聚点，在客户进程和服务器进程二者之间传递数据。如下图所示。










XSI IPC
有三种称作XSI IPC的IPC：消息队列、信号量、共享存储器。
每个内核中IPC结构都有一个非负整数的标识符加以引用；标识符是IPC对象的内部名。
XSI IPC为每个IPC结构关联了一个ipc_perm结构。在创建IPC结构时，对所有字段都赋初值。
以上3中形式的XSI IPC都有内置限制。大多数限制可以通过重新配置内核来改变。
消息队列
消息队列是消息的连接表，存储在内核中，由消息队列标识符标识。msgget用于创建一个新队列或打开一个现有队列。msgsnd将新消息添加到队列尾端。msgrcv用于从队列中读取消息。
msgctl函数对队列多种操作。它和另外两个信号量及各项存储有关的函数semctl和shmctl都类似于ioctl的函数。
信号量
信号量是一个计数器，用于多个进程提供对共享数据对象的访问。
为了获取共享资源，进程需要执行下列操作：
测试控制该资源的信号量；
若此信号的值为正，则进程可以使用该资源。在这种情况下，进程将信号量值减1；
否则，若此信号量的值为0，则进程进入休眠状态，直至信号量值大于0。进程被唤醒，返回步骤1.
XSI信号量与此相比要复杂得多：
信号量并非单个非负值，而必须定义为含有一个或多个值的集合；
信号量的创建独立于它的初始化，因此不能原子地创建一个信号量集合；
信号量的是否必须手动。
semget获取一个信号量ID；
semctl包含了多种信号量操作；
semop自动执行信号量集合上的操作数组；
共享存储
共享存储允许两个或多个进程共享一个给定的存储区。因为数据不需要在客户进程和服务器进程之间复制。使用共享存储时要掌握的乔明是在多个进程之间同步访问一个给定的存储区。通常信号量由于同步共享存储访问。
shmget获取一个共享存储ID；
shmctl对共享存储段执行多种操作；
shmat一旦创建了一个共享存储段，进程可以将其连接到它的地址空间；
shmdt函数用于分离相应的共享存储段。
第16章  网络IPC：套接字
以上所述的IPC机制是在同一台计算机上运行的进程间通信，本章将介绍在不同结算及上的进程相互通信的机制：网络进程间通信。
套接字描述符
套接字时通信断点的抽象，应用程序用套接字描述符访问套接字。
为了创建一个套接字，调用socket函数。套接字通信时双向。可以采用shutdown函数来机制一个套接字的IO。
寻址
进程标识由两部分组成：计算机网络地址；端口号。
1.字节序
如果处理器架构支持打断字节序，那么最大字节地址出现在最低有效字节上；小端字节序则相反：最低有效字节包含最小字节地址。
网络协议指定了字节序，因此异构计算机系统能够交换协议信息而不被字节序所混淆。TCPIP协议栈使用大端字节序。
2.地址格式
为了使得不同格式地址能够传入到套接字函数，地址会被强制转换成一个通用的地址结构能够传入到套接字函数，地址会被强制转换成一个通用的地址结构。并且套接字实现可以自由得添加额外的成员。
3.地址查询
通过调用gethostent函数可以找到给定计算机系统的主机信息。
getnetbyaddr和getnetbyname函数可以获得网络名字和网络编号。
每个服务由一个唯一的冲所周知的端口号来支持。可以使用函数getservbyname姜一个服务器映射到一个端口号，使用函数getservbyport姜一个端口号映射到一个服务名。使用getservent顺序扫描服务数据库。
Getaddrinfo函数允许件给一个主机名和一个服务名映射到一个地址；
4.将套接字与地址关联
使用bind函数来关联地址和套接字
Getsockname函数来发现绑定到套接字上的地址。
如果套接字已经和对方连接，可以调用getpeername函数来找到对方的地址。
建立连接
在开始交换数据以前，需要在请求服务的进程套接字和提供服务器的进程套接字之间建立一个连接。使用connect函数来建立连接。
服务器调用listen函数来宣告他是否愿意接受连接请求。一旦服务器调用了listen，所用的套接字就能接受连接请求。使用accept函数获得连接请求并建立连接。
数据传输
3个函数用于发送数据，3个用于接受数据
Send函数指定标致来改变处理传输数据的方式。Sendto函数可以在无连接的套接字上指定一个目标地址。Sendto提供了发送报文的另一种方式。
Sendmsg函数来指定多重缓冲区传输数据。
Recv可以指定标致来控制如何接受数据。
Recvfrom定位发送者，得到数据发送者的原地址。
Recvmsg指定接受数据的输入缓冲区。
套接字选项
套接字机制提供两个套接字选项借口来控制套接字行为。一个借口原来设置选项，有一个借口可以查询选项的状态。
Setsockopt函数来设置套接字选项；
Getsockopt函数查看选项的当前值。
带外数据
TCP姜带外数据成为紧急数据。TCP仅仅支持一个字节的技术局，但是也许紧急数据在普通数据传递机制数据流之外传输。
非阻塞和异步IO
通常，recv函数没有数据可用时会阻塞等待。同样地，当套接字输出队列没有足够空间来发送消息时，send函数会阻塞。在套接字飞阻塞模式下，行为会改变，在这种情况下，浙西额函数不会阻塞而是会失败。当这种情况发生时，可以使用poll或者select来判断能否接受或传输数据。
在基于套机子的异步IO中，当从套接字中读取数据时，或者当套接字写队列中空间变得可用时，可以安排发送信号。
建立套接字所有权，这样信号可以被传递到合适的进程。
通知套接字当IO操作不会阻塞时发送信号。

以上是我的读写笔记，接下来，用c语言实现书中第9章习题9.2。
编写一段程序调用fork并使子进程建立一个新的会话。验证子进程变成进程组组长且不再有控制终端。
#include<stdio.h>
#include<error.h>
#include<unistd.h>
#include<stdlib.h>
int main(void){
        int pid,gpid;
        pid=fork();
        if(pid==-1){
                perror("FORK ERROR");
                exit(0);
        }
        else if(pid==0){
                //创建会话
                gpid=setsid();
                if(gpid==-1){
                        perror("SETSID ERROR");
                        exit(0);
                }
                //验证子进程变成进程组组长
                else {
                        pid=getpid();
                        printf("pid=%ld,pgrp=%ld\n",(long)pid,(long)gpid);
                }
                //验证子进程不再有控制终端
                if(execlp("ps","ps","-o","pid,pgrp,tty,comm",NULL)<0){
                        perror("EXECLP ERROR");
                        exit(0);
                }
        }
        exit(0);
}
验证子进程变成进程组组长
验证子进程不再有控制终端
